/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ClientPoliciesRepresentation } from '../model/clientPoliciesRepresentation';
import { ClientProfilesRepresentation } from '../model/clientProfilesRepresentation';
import { ClientRepresentation } from '../model/clientRepresentation';
import { GlobalRequestResult } from '../model/globalRequestResult';
import { GroupRepresentation } from '../model/groupRepresentation';
import { ManagementPermissionReference } from '../model/managementPermissionReference';
import { RealmEventsConfigRepresentation } from '../model/realmEventsConfigRepresentation';
import { RealmRepresentation } from '../model/realmRepresentation';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class RealmsAdminService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete all admin events
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmAdminEventsDelete(realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmAdminEventsDelete(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmAdminEventsDelete(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmAdminEventsDelete(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmAdminEventsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/admin-events`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get admin events   Returns all admin events, or filters events based on URL query parameters listed here
     * 
     * @param realm realm name (not id!)
     * @param authClient 
     * @param authIpAddress 
     * @param authRealm 
     * @param authUser user id
     * @param dateFrom 
     * @param dateTo 
     * @param first 
     * @param max Maximum results size (defaults to 100)
     * @param operationTypes 
     * @param resourcePath 
     * @param resourceTypes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmAdminEventsGet(realm: string, authClient?: string, authIpAddress?: string, authRealm?: string, authUser?: string, dateFrom?: string, dateTo?: string, first?: number, max?: number, operationTypes?: Array<string>, resourcePath?: string, resourceTypes?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmAdminEventsGet(realm: string, authClient?: string, authIpAddress?: string, authRealm?: string, authUser?: string, dateFrom?: string, dateTo?: string, first?: number, max?: number, operationTypes?: Array<string>, resourcePath?: string, resourceTypes?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmAdminEventsGet(realm: string, authClient?: string, authIpAddress?: string, authRealm?: string, authUser?: string, dateFrom?: string, dateTo?: string, first?: number, max?: number, operationTypes?: Array<string>, resourcePath?: string, resourceTypes?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmAdminEventsGet(realm: string, authClient?: string, authIpAddress?: string, authRealm?: string, authUser?: string, dateFrom?: string, dateTo?: string, first?: number, max?: number, operationTypes?: Array<string>, resourcePath?: string, resourceTypes?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmAdminEventsGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (authClient !== undefined && authClient !== null) {
            queryParameters = queryParameters.set('authClient', <any>authClient);
        }
        if (authIpAddress !== undefined && authIpAddress !== null) {
            queryParameters = queryParameters.set('authIpAddress', <any>authIpAddress);
        }
        if (authRealm !== undefined && authRealm !== null) {
            queryParameters = queryParameters.set('authRealm', <any>authRealm);
        }
        if (authUser !== undefined && authUser !== null) {
            queryParameters = queryParameters.set('authUser', <any>authUser);
        }
        if (dateFrom !== undefined && dateFrom !== null) {
            queryParameters = queryParameters.set('dateFrom', <any>dateFrom);
        }
        if (dateTo !== undefined && dateTo !== null) {
            queryParameters = queryParameters.set('dateTo', <any>dateTo);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (operationTypes) {
            operationTypes.forEach((element) => {
                queryParameters = queryParameters.append('operationTypes', <any>element);
            })
        }
        if (resourcePath !== undefined && resourcePath !== null) {
            queryParameters = queryParameters.set('resourcePath', <any>resourcePath);
        }
        if (resourceTypes) {
            resourceTypes.forEach((element) => {
                queryParameters = queryParameters.append('resourceTypes', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/admin-events`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Base path for importing clients under this realm.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientDescriptionConverterPost(body: string, realm: string, observe?: 'body', reportProgress?: boolean): Observable<ClientRepresentation>;
    public realmClientDescriptionConverterPost(body: string, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientRepresentation>>;
    public realmClientDescriptionConverterPost(body: string, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientRepresentation>>;
    public realmClientDescriptionConverterPost(body: string, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientDescriptionConverterPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientDescriptionConverterPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ClientRepresentation>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/client-description-converter`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientPoliciesPoliciesGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<ClientPoliciesRepresentation>;
    public realmClientPoliciesPoliciesGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientPoliciesRepresentation>>;
    public realmClientPoliciesPoliciesGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientPoliciesRepresentation>>;
    public realmClientPoliciesPoliciesGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientPoliciesPoliciesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientPoliciesRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/client-policies/policies`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientPoliciesPoliciesPut(body: ClientPoliciesRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientPoliciesPoliciesPut(body: ClientPoliciesRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientPoliciesPoliciesPut(body: ClientPoliciesRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientPoliciesPoliciesPut(body: ClientPoliciesRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientPoliciesPoliciesPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientPoliciesPoliciesPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/client-policies/policies`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param includeGlobalProfiles 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientPoliciesProfilesGet(realm: string, includeGlobalProfiles?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ClientProfilesRepresentation>;
    public realmClientPoliciesProfilesGet(realm: string, includeGlobalProfiles?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientProfilesRepresentation>>;
    public realmClientPoliciesProfilesGet(realm: string, includeGlobalProfiles?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientProfilesRepresentation>>;
    public realmClientPoliciesProfilesGet(realm: string, includeGlobalProfiles?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientPoliciesProfilesGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeGlobalProfiles !== undefined && includeGlobalProfiles !== null) {
            queryParameters = queryParameters.set('include-global-profiles', <any>includeGlobalProfiles);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientProfilesRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/client-policies/profiles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientPoliciesProfilesPut(body: ClientProfilesRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientPoliciesProfilesPut(body: ClientProfilesRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientPoliciesProfilesPut(body: ClientProfilesRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientPoliciesProfilesPut(body: ClientProfilesRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientPoliciesProfilesPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientPoliciesProfilesPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/client-policies/profiles`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get client session stats   Returns a JSON map.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientSessionStatsGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientSessionStatsGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientSessionStatsGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientSessionStatsGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientSessionStatsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/client-session-stats`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmCredentialRegistratorsGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmCredentialRegistratorsGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmCredentialRegistratorsGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmCredentialRegistratorsGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmCredentialRegistratorsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/credential-registrators`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultDefaultClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultDefaultClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultDefaultClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultDefaultClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultDefaultClientScopesClientScopeIdDelete.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmDefaultDefaultClientScopesClientScopeIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/default-default-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultDefaultClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultDefaultClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultDefaultClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultDefaultClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultDefaultClientScopesClientScopeIdPut.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmDefaultDefaultClientScopesClientScopeIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/default-default-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get realm default client scopes.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultDefaultClientScopesGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmDefaultDefaultClientScopesGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmDefaultDefaultClientScopesGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmDefaultDefaultClientScopesGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultDefaultClientScopesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/default-default-client-scopes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get group hierarchy.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultGroupsGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmDefaultGroupsGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmDefaultGroupsGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmDefaultGroupsGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultGroupsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/default-groups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultGroupsGroupIdDelete(realm: string, groupId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultGroupsGroupIdDelete(realm: string, groupId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultGroupsGroupIdDelete(realm: string, groupId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultGroupsGroupIdDelete(realm: string, groupId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultGroupsGroupIdDelete.');
        }

        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling realmDefaultGroupsGroupIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/default-groups/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultGroupsGroupIdPut(realm: string, groupId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultGroupsGroupIdPut(realm: string, groupId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultGroupsGroupIdPut(realm: string, groupId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultGroupsGroupIdPut(realm: string, groupId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultGroupsGroupIdPut.');
        }

        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling realmDefaultGroupsGroupIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/default-groups/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultOptionalClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultOptionalClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultOptionalClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultOptionalClientScopesClientScopeIdDelete(realm: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultOptionalClientScopesClientScopeIdDelete.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmDefaultOptionalClientScopesClientScopeIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/default-optional-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultOptionalClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDefaultOptionalClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDefaultOptionalClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDefaultOptionalClientScopesClientScopeIdPut(realm: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultOptionalClientScopesClientScopeIdPut.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmDefaultOptionalClientScopesClientScopeIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/default-optional-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get realm optional client scopes.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDefaultOptionalClientScopesGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmDefaultOptionalClientScopesGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmDefaultOptionalClientScopesGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmDefaultOptionalClientScopesGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDefaultOptionalClientScopesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/default-optional-client-scopes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the realm
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmDelete(realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmDelete(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmDelete(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmDelete(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the events provider configuration   Returns JSON object with events provider configuration
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmEventsConfigGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<RealmEventsConfigRepresentation>;
    public realmEventsConfigGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RealmEventsConfigRepresentation>>;
    public realmEventsConfigGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RealmEventsConfigRepresentation>>;
    public realmEventsConfigGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmEventsConfigGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RealmEventsConfigRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/events/config`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the events provider   Change the events provider and/or its configuration
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmEventsConfigPut(body: RealmEventsConfigRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmEventsConfigPut(body: RealmEventsConfigRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmEventsConfigPut(body: RealmEventsConfigRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmEventsConfigPut(body: RealmEventsConfigRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmEventsConfigPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmEventsConfigPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/events/config`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all events
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmEventsDelete(realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmEventsDelete(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmEventsDelete(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmEventsDelete(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmEventsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/events`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get events   Returns all events, or filters them based on URL query parameters listed here
     * 
     * @param realm realm name (not id!)
     * @param client App or oauth client name
     * @param dateFrom From date
     * @param dateTo To date
     * @param first Paging offset
     * @param ipAddress IP address
     * @param max Maximum results size (defaults to 100)
     * @param type The types of events to return
     * @param user User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmEventsGet(realm: string, client?: string, dateFrom?: string, dateTo?: string, first?: number, ipAddress?: string, max?: number, type?: Array<string>, user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmEventsGet(realm: string, client?: string, dateFrom?: string, dateTo?: string, first?: number, ipAddress?: string, max?: number, type?: Array<string>, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmEventsGet(realm: string, client?: string, dateFrom?: string, dateTo?: string, first?: number, ipAddress?: string, max?: number, type?: Array<string>, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmEventsGet(realm: string, client?: string, dateFrom?: string, dateTo?: string, first?: number, ipAddress?: string, max?: number, type?: Array<string>, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmEventsGet.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (client !== undefined && client !== null) {
            queryParameters = queryParameters.set('client', <any>client);
        }
        if (dateFrom !== undefined && dateFrom !== null) {
            queryParameters = queryParameters.set('dateFrom', <any>dateFrom);
        }
        if (dateTo !== undefined && dateTo !== null) {
            queryParameters = queryParameters.set('dateTo', <any>dateTo);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (ipAddress !== undefined && ipAddress !== null) {
            queryParameters = queryParameters.set('ipAddress', <any>ipAddress);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (type) {
            type.forEach((element) => {
                queryParameters = queryParameters.append('type', <any>element);
            })
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/events`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the top-level representation of the realm   It will not include nested information like User and Client representations.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<RealmRepresentation>;
    public realmGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RealmRepresentation>>;
    public realmGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RealmRepresentation>>;
    public realmGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RealmRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupByPathPathGet(realm: string, path: string, observe?: 'body', reportProgress?: boolean): Observable<GroupRepresentation>;
    public realmGroupByPathPathGet(realm: string, path: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GroupRepresentation>>;
    public realmGroupByPathPathGet(realm: string, path: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GroupRepresentation>>;
    public realmGroupByPathPathGet(realm: string, path: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupByPathPathGet.');
        }

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling realmGroupByPathPathGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GroupRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/group-by-path/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmLocalizationGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmLocalizationGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmLocalizationGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/localization`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param locale 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocaleDelete(realm: string, locale: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmLocalizationLocaleDelete(realm: string, locale: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmLocalizationLocaleDelete(realm: string, locale: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmLocalizationLocaleDelete(realm: string, locale: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocaleDelete.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocaleDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param locale 
     * @param useRealmDefaultLocaleFallback 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocaleGet(realm: string, locale: string, useRealmDefaultLocaleFallback?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmLocalizationLocaleGet(realm: string, locale: string, useRealmDefaultLocaleFallback?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmLocalizationLocaleGet(realm: string, locale: string, useRealmDefaultLocaleFallback?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmLocalizationLocaleGet(realm: string, locale: string, useRealmDefaultLocaleFallback?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocaleGet.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocaleGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (useRealmDefaultLocaleFallback !== undefined && useRealmDefaultLocaleFallback !== null) {
            queryParameters = queryParameters.set('useRealmDefaultLocaleFallback', <any>useRealmDefaultLocaleFallback);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param locale 
     * @param key 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocaleKeyDelete(realm: string, locale: string, key: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmLocalizationLocaleKeyDelete(realm: string, locale: string, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmLocalizationLocaleKeyDelete(realm: string, locale: string, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmLocalizationLocaleKeyDelete(realm: string, locale: string, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocaleKeyDelete.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocaleKeyDelete.');
        }

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling realmLocalizationLocaleKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}/${encodeURIComponent(String(key))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param locale 
     * @param key 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocaleKeyGet(realm: string, locale: string, key: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public realmLocalizationLocaleKeyGet(realm: string, locale: string, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public realmLocalizationLocaleKeyGet(realm: string, locale: string, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public realmLocalizationLocaleKeyGet(realm: string, locale: string, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocaleKeyGet.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocaleKeyGet.');
        }

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling realmLocalizationLocaleKeyGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<string>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}/${encodeURIComponent(String(key))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param locale 
     * @param key 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocaleKeyPut(body: string, realm: string, locale: string, key: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmLocalizationLocaleKeyPut(body: string, realm: string, locale: string, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmLocalizationLocaleKeyPut(body: string, realm: string, locale: string, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmLocalizationLocaleKeyPut(body: string, realm: string, locale: string, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmLocalizationLocaleKeyPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocaleKeyPut.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocaleKeyPut.');
        }

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling realmLocalizationLocaleKeyPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}/${encodeURIComponent(String(key))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param locale 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLocalizationLocalePost(body: { [key: string]: any; }, realm: string, locale: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmLocalizationLocalePost(body: { [key: string]: any; }, realm: string, locale: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmLocalizationLocalePost(body: { [key: string]: any; }, realm: string, locale: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmLocalizationLocalePost(body: { [key: string]: any; }, realm: string, locale: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmLocalizationLocalePost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLocalizationLocalePost.');
        }

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling realmLocalizationLocalePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/localization/${encodeURIComponent(String(locale))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes all user sessions.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmLogoutAllPost(realm: string, observe?: 'body', reportProgress?: boolean): Observable<GlobalRequestResult>;
    public realmLogoutAllPost(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GlobalRequestResult>>;
    public realmLogoutAllPost(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GlobalRequestResult>>;
    public realmLogoutAllPost(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmLogoutAllPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GlobalRequestResult>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/logout-all`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Partial export of existing realm into a JSON file.
     * 
     * @param realm realm name (not id!)
     * @param exportClients 
     * @param exportGroupsAndRoles 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmPartialExportPost(realm: string, exportClients?: boolean, exportGroupsAndRoles?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmPartialExportPost(realm: string, exportClients?: boolean, exportGroupsAndRoles?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmPartialExportPost(realm: string, exportClients?: boolean, exportGroupsAndRoles?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmPartialExportPost(realm: string, exportClients?: boolean, exportGroupsAndRoles?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmPartialExportPost.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (exportClients !== undefined && exportClients !== null) {
            queryParameters = queryParameters.set('exportClients', <any>exportClients);
        }
        if (exportGroupsAndRoles !== undefined && exportGroupsAndRoles !== null) {
            queryParameters = queryParameters.set('exportGroupsAndRoles', <any>exportGroupsAndRoles);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/partial-export`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Partial import from a JSON file to an existing realm.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmPartialImportPost(body: Array<{ [key: string]: any; }>, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmPartialImportPost(body: Array<{ [key: string]: any; }>, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmPartialImportPost(body: Array<{ [key: string]: any; }>, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmPartialImportPost(body: Array<{ [key: string]: any; }>, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmPartialImportPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmPartialImportPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/partialImport`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Push the realms revocation policy to any client that has an admin url associated with it.
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmPushRevocationPost(realm: string, observe?: 'body', reportProgress?: boolean): Observable<GlobalRequestResult>;
    public realmPushRevocationPost(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GlobalRequestResult>>;
    public realmPushRevocationPost(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GlobalRequestResult>>;
    public realmPushRevocationPost(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmPushRevocationPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GlobalRequestResult>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/push-revocation`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmPut(body: RealmRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmPut(body: RealmRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmPut(body: RealmRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmPut(body: RealmRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove a specific user session.
     * 
     * @param realm realm name (not id!)
     * @param session 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmSessionsSessionDelete(realm: string, session: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmSessionsSessionDelete(realm: string, session: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmSessionsSessionDelete(realm: string, session: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmSessionsSessionDelete(realm: string, session: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmSessionsSessionDelete.');
        }

        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling realmSessionsSessionDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/sessions/${encodeURIComponent(String(session))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmTestSMTPConnectionPost(body: { [key: string]: any; }, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmTestSMTPConnectionPost(body: { [key: string]: any; }, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmTestSMTPConnectionPost(body: { [key: string]: any; }, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmTestSMTPConnectionPost(body: { [key: string]: any; }, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmTestSMTPConnectionPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmTestSMTPConnectionPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/testSMTPConnection`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersManagementPermissionsGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmUsersManagementPermissionsGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmUsersManagementPermissionsGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmUsersManagementPermissionsGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersManagementPermissionsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ManagementPermissionReference>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users-management-permissions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersManagementPermissionsPut(body: ManagementPermissionReference, realm: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmUsersManagementPermissionsPut(body: ManagementPermissionReference, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmUsersManagementPermissionsPut(body: ManagementPermissionReference, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmUsersManagementPermissionsPut(body: ManagementPermissionReference, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersManagementPermissionsPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersManagementPermissionsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ManagementPermissionReference>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users-management-permissions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Import a realm.
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rootPost(body: Array<{ [key: string]: any; }>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public rootPost(body: Array<{ [key: string]: any; }>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public rootPost(body: Array<{ [key: string]: any; }>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public rootPost(body: Array<{ [key: string]: any; }>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling rootPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
