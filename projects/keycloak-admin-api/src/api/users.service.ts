/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CredentialRepresentation } from '../model/credentialRepresentation';
import { FederatedIdentityRepresentation } from '../model/federatedIdentityRepresentation';
import { UserRepresentation } from '../model/userRepresentation';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UsersService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns the number of users that match the given criteria.
     * 
     * @param realm realm name (not id!)
     * @param email email filter
     * @param emailVerified 
     * @param enabled Boolean representing if user is enabled or not
     * @param firstName first name filter
     * @param lastName last name filter
     * @param search arbitrary search string for all the fields below
     * @param username username filter
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersCountGet(realm: string, email?: string, emailVerified?: boolean, enabled?: boolean, firstName?: string, lastName?: string, search?: string, username?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public realmUsersCountGet(realm: string, email?: string, emailVerified?: boolean, enabled?: boolean, firstName?: string, lastName?: string, search?: string, username?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public realmUsersCountGet(realm: string, email?: string, emailVerified?: boolean, enabled?: boolean, firstName?: string, lastName?: string, search?: string, username?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public realmUsersCountGet(realm: string, email?: string, emailVerified?: boolean, enabled?: boolean, firstName?: string, lastName?: string, search?: string, username?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersCountGet.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (email !== undefined && email !== null) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (emailVerified !== undefined && emailVerified !== null) {
            queryParameters = queryParameters.set('emailVerified', <any>emailVerified);
        }
        if (enabled !== undefined && enabled !== null) {
            queryParameters = queryParameters.set('enabled', <any>enabled);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('firstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('lastName', <any>lastName);
        }
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (username !== undefined && username !== null) {
            queryParameters = queryParameters.set('username', <any>username);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<number>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get users   Returns a stream of users, filtered according to query parameters.
     * 
     * @param realm realm name (not id!)
     * @param briefRepresentation Boolean which defines whether brief representations are returned (default: false)
     * @param email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
     * @param emailVerified whether the email has been verified
     * @param enabled Boolean representing if user is enabled or not
     * @param exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
     * @param first Pagination offset
     * @param firstName A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
     * @param idpAlias The alias of an Identity Provider linked to the user
     * @param idpUserId The userId at an Identity Provider linked to the user
     * @param lastName A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
     * @param max Maximum results size (defaults to 100)
     * @param q A query to search for custom attributes, in the format &#x27;key1:value2 key2:value2&#x27;
     * @param search A String contained in username, first or last name, or email
     * @param username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersGet(realm: string, briefRepresentation?: boolean, email?: string, emailVerified?: boolean, enabled?: boolean, exact?: boolean, first?: number, firstName?: string, idpAlias?: string, idpUserId?: string, lastName?: string, max?: number, q?: string, search?: string, username?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersGet(realm: string, briefRepresentation?: boolean, email?: string, emailVerified?: boolean, enabled?: boolean, exact?: boolean, first?: number, firstName?: string, idpAlias?: string, idpUserId?: string, lastName?: string, max?: number, q?: string, search?: string, username?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersGet(realm: string, briefRepresentation?: boolean, email?: string, emailVerified?: boolean, enabled?: boolean, exact?: boolean, first?: number, firstName?: string, idpAlias?: string, idpUserId?: string, lastName?: string, max?: number, q?: string, search?: string, username?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersGet(realm: string, briefRepresentation?: boolean, email?: string, emailVerified?: boolean, enabled?: boolean, exact?: boolean, first?: number, firstName?: string, idpAlias?: string, idpUserId?: string, lastName?: string, max?: number, q?: string, search?: string, username?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersGet.');
        }















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (briefRepresentation !== undefined && briefRepresentation !== null) {
            queryParameters = queryParameters.set('briefRepresentation', <any>briefRepresentation);
        }
        if (email !== undefined && email !== null) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (emailVerified !== undefined && emailVerified !== null) {
            queryParameters = queryParameters.set('emailVerified', <any>emailVerified);
        }
        if (enabled !== undefined && enabled !== null) {
            queryParameters = queryParameters.set('enabled', <any>enabled);
        }
        if (exact !== undefined && exact !== null) {
            queryParameters = queryParameters.set('exact', <any>exact);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('firstName', <any>firstName);
        }
        if (idpAlias !== undefined && idpAlias !== null) {
            queryParameters = queryParameters.set('idpAlias', <any>idpAlias);
        }
        if (idpUserId !== undefined && idpUserId !== null) {
            queryParameters = queryParameters.set('idpUserId', <any>idpUserId);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('lastName', <any>lastName);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (q !== undefined && q !== null) {
            queryParameters = queryParameters.set('q', <any>q);
        }
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (username !== undefined && username !== null) {
            queryParameters = queryParameters.set('username', <any>username);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return credential types, which are provided by the user storage where user is stored.
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdConfiguredUserStorageCredentialTypesGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdConfiguredUserStorageCredentialTypesGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdConfiguredUserStorageCredentialTypesGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdConfiguredUserStorageCredentialTypesGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdConfiguredUserStorageCredentialTypesGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdConfiguredUserStorageCredentialTypesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/configured-user-storage-credential-types`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revoke consent and offline tokens for particular client from user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param client Client id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdConsentsClientDelete(realm: string, id: string, client: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdConsentsClientDelete(realm: string, id: string, client: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdConsentsClientDelete(realm: string, id: string, client: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdConsentsClientDelete(realm: string, id: string, client: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdConsentsClientDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdConsentsClientDelete.');
        }

        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling realmUsersIdConsentsClientDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/consents/${encodeURIComponent(String(client))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get consents granted by the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdConsentsGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdConsentsGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdConsentsGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdConsentsGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdConsentsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdConsentsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/consents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove a credential for a user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param credentialId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdCredentialsCredentialIdDelete(realm: string, id: string, credentialId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdCredentialsCredentialIdDelete(realm: string, id: string, credentialId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdCredentialsCredentialIdDelete(realm: string, id: string, credentialId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdCredentialsCredentialIdDelete(realm: string, id: string, credentialId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdCredentialsCredentialIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdCredentialsCredentialIdDelete.');
        }

        if (credentialId === null || credentialId === undefined) {
            throw new Error('Required parameter credentialId was null or undefined when calling realmUsersIdCredentialsCredentialIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/credentials/${encodeURIComponent(String(credentialId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Move a credential to a position behind another credential
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param credentialId The credential to move
     * @param newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(realm: string, id: string, credentialId: string, newPreviousCredentialId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(realm: string, id: string, credentialId: string, newPreviousCredentialId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(realm: string, id: string, credentialId: string, newPreviousCredentialId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(realm: string, id: string, credentialId: string, newPreviousCredentialId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost.');
        }

        if (credentialId === null || credentialId === undefined) {
            throw new Error('Required parameter credentialId was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost.');
        }

        if (newPreviousCredentialId === null || newPreviousCredentialId === undefined) {
            throw new Error('Required parameter newPreviousCredentialId was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/credentials/${encodeURIComponent(String(credentialId))}/moveAfter/${encodeURIComponent(String(newPreviousCredentialId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Move a credential to a first position in the credentials list of the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param credentialId The credential to move
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdCredentialsCredentialIdMoveToFirstPost(realm: string, id: string, credentialId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdCredentialsCredentialIdMoveToFirstPost(realm: string, id: string, credentialId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdCredentialsCredentialIdMoveToFirstPost(realm: string, id: string, credentialId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdCredentialsCredentialIdMoveToFirstPost(realm: string, id: string, credentialId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveToFirstPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveToFirstPost.');
        }

        if (credentialId === null || credentialId === undefined) {
            throw new Error('Required parameter credentialId was null or undefined when calling realmUsersIdCredentialsCredentialIdMoveToFirstPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/credentials/${encodeURIComponent(String(credentialId))}/moveToFirst`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a credential label for a user
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id User id
     * @param credentialId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdCredentialsCredentialIdUserLabelPut(body: string, realm: string, id: string, credentialId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdCredentialsCredentialIdUserLabelPut(body: string, realm: string, id: string, credentialId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdCredentialsCredentialIdUserLabelPut(body: string, realm: string, id: string, credentialId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdCredentialsCredentialIdUserLabelPut(body: string, realm: string, id: string, credentialId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdCredentialsCredentialIdUserLabelPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdCredentialsCredentialIdUserLabelPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdCredentialsCredentialIdUserLabelPut.');
        }

        if (credentialId === null || credentialId === undefined) {
            throw new Error('Required parameter credentialId was null or undefined when calling realmUsersIdCredentialsCredentialIdUserLabelPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/credentials/${encodeURIComponent(String(credentialId))}/userLabel`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdCredentialsGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdCredentialsGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdCredentialsGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdCredentialsGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdCredentialsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdCredentialsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/credentials`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdDelete(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdDelete(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdDelete(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdDelete(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Disable all credentials for a user of a specific type
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdDisableCredentialTypesPut(body: Array<string>, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdDisableCredentialTypesPut(body: Array<string>, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdDisableCredentialTypesPut(body: Array<string>, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdDisableCredentialTypesPut(body: Array<string>, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdDisableCredentialTypesPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdDisableCredentialTypesPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdDisableCredentialTypesPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/disable-credential-types`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send an email to the user with a link they can click to execute particular actions.
     * 
     * @param body Required actions the user needs to complete
     * @param realm realm name (not id!)
     * @param id User id
     * @param clientId Client id
     * @param lifespan Number of seconds after which the generated token expires
     * @param redirectUri Redirect uri
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdExecuteActionsEmailPut(body: Array<string>, realm: string, id: string, clientId?: string, lifespan?: number, redirectUri?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdExecuteActionsEmailPut(body: Array<string>, realm: string, id: string, clientId?: string, lifespan?: number, redirectUri?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdExecuteActionsEmailPut(body: Array<string>, realm: string, id: string, clientId?: string, lifespan?: number, redirectUri?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdExecuteActionsEmailPut(body: Array<string>, realm: string, id: string, clientId?: string, lifespan?: number, redirectUri?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdExecuteActionsEmailPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdExecuteActionsEmailPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdExecuteActionsEmailPut.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        if (lifespan !== undefined && lifespan !== null) {
            queryParameters = queryParameters.set('lifespan', <any>lifespan);
        }
        if (redirectUri !== undefined && redirectUri !== null) {
            queryParameters = queryParameters.set('redirect_uri', <any>redirectUri);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/execute-actions-email`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get social logins associated with the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdFederatedIdentityGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdFederatedIdentityGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdFederatedIdentityGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdFederatedIdentityGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdFederatedIdentityGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdFederatedIdentityGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/federated-identity`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove a social login provider from user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param provider Social login provider id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdFederatedIdentityProviderDelete(realm: string, id: string, provider: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdFederatedIdentityProviderDelete(realm: string, id: string, provider: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdFederatedIdentityProviderDelete(realm: string, id: string, provider: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdFederatedIdentityProviderDelete(realm: string, id: string, provider: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdFederatedIdentityProviderDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdFederatedIdentityProviderDelete.');
        }

        if (provider === null || provider === undefined) {
            throw new Error('Required parameter provider was null or undefined when calling realmUsersIdFederatedIdentityProviderDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/federated-identity/${encodeURIComponent(String(provider))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a social login provider to the user
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id User id
     * @param provider Social login provider id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdFederatedIdentityProviderPost(body: FederatedIdentityRepresentation, realm: string, id: string, provider: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdFederatedIdentityProviderPost(body: FederatedIdentityRepresentation, realm: string, id: string, provider: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdFederatedIdentityProviderPost(body: FederatedIdentityRepresentation, realm: string, id: string, provider: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdFederatedIdentityProviderPost(body: FederatedIdentityRepresentation, realm: string, id: string, provider: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdFederatedIdentityProviderPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdFederatedIdentityProviderPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdFederatedIdentityProviderPost.');
        }

        if (provider === null || provider === undefined) {
            throw new Error('Required parameter provider was null or undefined when calling realmUsersIdFederatedIdentityProviderPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/federated-identity/${encodeURIComponent(String(provider))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get representation of the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<UserRepresentation>;
    public realmUsersIdGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserRepresentation>>;
    public realmUsersIdGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserRepresentation>>;
    public realmUsersIdGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param search 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdGroupsCountGet(realm: string, id: string, search?: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmUsersIdGroupsCountGet(realm: string, id: string, search?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmUsersIdGroupsCountGet(realm: string, id: string, search?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmUsersIdGroupsCountGet(realm: string, id: string, search?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdGroupsCountGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdGroupsCountGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/groups/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param briefRepresentation 
     * @param first 
     * @param max 
     * @param search 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdGroupsGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, search?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdGroupsGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, search?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdGroupsGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, search?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdGroupsGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, search?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdGroupsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdGroupsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (briefRepresentation !== undefined && briefRepresentation !== null) {
            queryParameters = queryParameters.set('briefRepresentation', <any>briefRepresentation);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdGroupsGroupIdDelete(realm: string, id: string, groupId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdGroupsGroupIdDelete(realm: string, id: string, groupId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdGroupsGroupIdDelete(realm: string, id: string, groupId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdGroupsGroupIdDelete(realm: string, id: string, groupId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdGroupsGroupIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdGroupsGroupIdDelete.');
        }

        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling realmUsersIdGroupsGroupIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/groups/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdGroupsGroupIdPut(realm: string, id: string, groupId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdGroupsGroupIdPut(realm: string, id: string, groupId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdGroupsGroupIdPut(realm: string, id: string, groupId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdGroupsGroupIdPut(realm: string, id: string, groupId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdGroupsGroupIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdGroupsGroupIdPut.');
        }

        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling realmUsersIdGroupsGroupIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/groups/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Impersonate the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdImpersonationPost(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmUsersIdImpersonationPost(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmUsersIdImpersonationPost(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmUsersIdImpersonationPost(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdImpersonationPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdImpersonationPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/impersonation`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdLogoutPost(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdLogoutPost(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdLogoutPost(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdLogoutPost(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdLogoutPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdLogoutPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/logout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get offline sessions associated with the user and client
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param clientUuid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdOfflineSessionsClientUuidGet(realm: string, id: string, clientUuid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdOfflineSessionsClientUuidGet(realm: string, id: string, clientUuid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdOfflineSessionsClientUuidGet(realm: string, id: string, clientUuid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdOfflineSessionsClientUuidGet(realm: string, id: string, clientUuid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdOfflineSessionsClientUuidGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdOfflineSessionsClientUuidGet.');
        }

        if (clientUuid === null || clientUuid === undefined) {
            throw new Error('Required parameter clientUuid was null or undefined when calling realmUsersIdOfflineSessionsClientUuidGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/offline-sessions/${encodeURIComponent(String(clientUuid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the user
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdPut(body: UserRepresentation, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdPut(body: UserRepresentation, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdPut(body: UserRepresentation, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdPut(body: UserRepresentation, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set up a new password for the user.
     * 
     * @param body The representation must contain a rawPassword with the plain-text password
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdResetPasswordPut(body: CredentialRepresentation, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdResetPasswordPut(body: CredentialRepresentation, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdResetPasswordPut(body: CredentialRepresentation, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdResetPasswordPut(body: CredentialRepresentation, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersIdResetPasswordPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdResetPasswordPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdResetPasswordPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/reset-password`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param clientId Client id
     * @param redirectUri Redirect uri
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdSendVerifyEmailPut(realm: string, id: string, clientId?: string, redirectUri?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersIdSendVerifyEmailPut(realm: string, id: string, clientId?: string, redirectUri?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersIdSendVerifyEmailPut(realm: string, id: string, clientId?: string, redirectUri?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersIdSendVerifyEmailPut(realm: string, id: string, clientId?: string, redirectUri?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdSendVerifyEmailPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdSendVerifyEmailPut.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        if (redirectUri !== undefined && redirectUri !== null) {
            queryParameters = queryParameters.set('redirect_uri', <any>redirectUri);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/send-verify-email`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get sessions associated with the user
     * 
     * @param realm realm name (not id!)
     * @param id User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersIdSessionsGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmUsersIdSessionsGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmUsersIdSessionsGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmUsersIdSessionsGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersIdSessionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmUsersIdSessionsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/${encodeURIComponent(String(id))}/sessions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new user   Username must be unique.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersPost(body: UserRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersPost(body: UserRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersPost(body: UserRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersPost(body: UserRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/users`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersProfileGet(realm: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public realmUsersProfileGet(realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public realmUsersProfileGet(realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public realmUsersProfileGet(realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersProfileGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<string>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/users/profile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmUsersProfilePut(body: string, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmUsersProfilePut(body: string, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmUsersProfilePut(body: string, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmUsersProfilePut(body: string, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmUsersProfilePut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmUsersProfilePut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/users/profile`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
