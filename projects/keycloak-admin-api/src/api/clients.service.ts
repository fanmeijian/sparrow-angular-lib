/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AccessToken } from '../model/accessToken';
import { ClientRepresentation } from '../model/clientRepresentation';
import { CredentialRepresentation } from '../model/credentialRepresentation';
import { GlobalRequestResult } from '../model/globalRequestResult';
import { IDToken } from '../model/iDToken';
import { ManagementPermissionReference } from '../model/managementPermissionReference';
import { UserRepresentation } from '../model/userRepresentation';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ClientsService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get clients belonging to the realm.
     * 
     * @param realm realm name (not id!)
     * @param clientId filter by clientId
     * @param first the first result
     * @param max the max results to return
     * @param q 
     * @param search whether this is a search query or a getClientById query
     * @param viewableOnly filter clients that cannot be viewed in full by admin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsGet(realm: string, clientId?: string, first?: number, max?: number, q?: string, search?: boolean, viewableOnly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsGet(realm: string, clientId?: string, first?: number, max?: number, q?: string, search?: boolean, viewableOnly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsGet(realm: string, clientId?: string, first?: number, max?: number, q?: string, search?: boolean, viewableOnly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsGet(realm: string, clientId?: string, first?: number, max?: number, q?: string, search?: boolean, viewableOnly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsGet.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (q !== undefined && q !== null) {
            queryParameters = queryParameters.set('q', <any>q);
        }
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (viewableOnly !== undefined && viewableOnly !== null) {
            queryParameters = queryParameters.set('viewableOnly', <any>viewableOnly);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the client secret
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdClientSecretGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<CredentialRepresentation>;
    public realmClientsIdClientSecretGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CredentialRepresentation>>;
    public realmClientsIdClientSecretGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CredentialRepresentation>>;
    public realmClientsIdClientSecretGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdClientSecretGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdClientSecretGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CredentialRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/client-secret`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate a new secret for the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdClientSecretPost(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<CredentialRepresentation>;
    public realmClientsIdClientSecretPost(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CredentialRepresentation>>;
    public realmClientsIdClientSecretPost(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CredentialRepresentation>>;
    public realmClientsIdClientSecretPost(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdClientSecretPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdClientSecretPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CredentialRepresentation>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/client-secret`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Invalidate the rotated secret for the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdClientSecretRotatedDelete(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdClientSecretRotatedDelete(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdClientSecretRotatedDelete(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdClientSecretRotatedDelete(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdClientSecretRotatedDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdClientSecretRotatedDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/client-secret/rotated`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the rotated client secret
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdClientSecretRotatedGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<CredentialRepresentation>;
    public realmClientsIdClientSecretRotatedGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CredentialRepresentation>>;
    public realmClientsIdClientSecretRotatedGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CredentialRepresentation>>;
    public realmClientsIdClientSecretRotatedGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdClientSecretRotatedGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdClientSecretRotatedGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CredentialRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/client-secret/rotated`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdDefaultClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdDefaultClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdDefaultClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdDefaultClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdDelete.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/default-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdDefaultClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdDefaultClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdDefaultClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdDefaultClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdPut.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmClientsIdDefaultClientScopesClientScopeIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/default-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get default client scopes.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdDefaultClientScopesGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdDefaultClientScopesGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdDefaultClientScopesGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdDefaultClientScopesGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdDefaultClientScopesGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdDefaultClientScopesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/default-client-scopes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdDelete(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdDelete(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdDelete(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdDelete(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create JSON with payload of example access token
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param scope 
     * @param userId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'body', reportProgress?: boolean): Observable<AccessToken>;
    public realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AccessToken>>;
    public realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AccessToken>>;
    public realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(realm: string, id: string, scope?: string, userId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AccessToken>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/generate-example-access-token`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create JSON with payload of example id token
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param scope 
     * @param userId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'body', reportProgress?: boolean): Observable<IDToken>;
    public realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IDToken>>;
    public realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IDToken>>;
    public realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(realm: string, id: string, scope?: string, userId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleIdTokenGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleIdTokenGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<IDToken>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/generate-example-id-token`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create JSON with payload of example user info
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param scope 
     * @param userId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(realm: string, id: string, scope?: string, userId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(realm: string, id: string, scope?: string, userId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleUserinfoGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesGenerateExampleUserinfoGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/generate-example-userinfo`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param scope 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesProtocolMappersGet(realm: string, id: string, scope?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdEvaluateScopesProtocolMappersGet(realm: string, id: string, scope?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesProtocolMappersGet(realm: string, id: string, scope?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesProtocolMappersGet(realm: string, id: string, scope?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesProtocolMappersGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesProtocolMappersGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/protocol-mappers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param roleContainerId either realm name OR client UUID
     * @param scope 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet.');
        }

        if (roleContainerId === null || roleContainerId === undefined) {
            throw new Error('Required parameter roleContainerId was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/scope-mappings/${encodeURIComponent(String(roleContainerId))}/granted`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get roles, which this client doesn’t have scope for and can’t have them in the accessToken issued for him.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param roleContainerId either realm name OR client UUID
     * @param scope 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(realm: string, id: string, roleContainerId: string, scope?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet.');
        }

        if (roleContainerId === null || roleContainerId === undefined) {
            throw new Error('Required parameter roleContainerId was null or undefined when calling realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/evaluate-scopes/scope-mappings/${encodeURIComponent(String(roleContainerId))}/not-granted`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get representation of the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ClientRepresentation>;
    public realmClientsIdGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientRepresentation>>;
    public realmClientsIdGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientRepresentation>>;
    public realmClientsIdGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param providerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdInstallationProvidersProviderIdGet(realm: string, id: string, providerId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdInstallationProvidersProviderIdGet(realm: string, id: string, providerId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdInstallationProvidersProviderIdGet(realm: string, id: string, providerId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdInstallationProvidersProviderIdGet(realm: string, id: string, providerId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdInstallationProvidersProviderIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdInstallationProvidersProviderIdGet.');
        }

        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling realmClientsIdInstallationProvidersProviderIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/installation/providers/${encodeURIComponent(String(providerId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdManagementPermissionsGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmClientsIdManagementPermissionsGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmClientsIdManagementPermissionsGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmClientsIdManagementPermissionsGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdManagementPermissionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdManagementPermissionsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ManagementPermissionReference>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/management/permissions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmClientsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmClientsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmClientsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientsIdManagementPermissionsPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdManagementPermissionsPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdManagementPermissionsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ManagementPermissionReference>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/management/permissions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unregister a cluster node from the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param node 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdNodesNodeDelete(realm: string, id: string, node: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdNodesNodeDelete(realm: string, id: string, node: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdNodesNodeDelete(realm: string, id: string, node: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdNodesNodeDelete(realm: string, id: string, node: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdNodesNodeDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdNodesNodeDelete.');
        }

        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling realmClientsIdNodesNodeDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/nodes/${encodeURIComponent(String(node))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Register a cluster node with the client   Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdNodesPost(body: { [key: string]: any; }, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdNodesPost(body: { [key: string]: any; }, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdNodesPost(body: { [key: string]: any; }, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdNodesPost(body: { [key: string]: any; }, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientsIdNodesPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdNodesPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdNodesPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/nodes`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get application offline session count   Returns a number of offline user sessions associated with this client   {      \&quot;count\&quot;: number  }
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdOfflineSessionCountGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmClientsIdOfflineSessionCountGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmClientsIdOfflineSessionCountGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmClientsIdOfflineSessionCountGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdOfflineSessionCountGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdOfflineSessionCountGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/offline-session-count`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get offline sessions for client   Returns a list of offline user sessions associated with this client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param first Paging offset
     * @param max Maximum results size (defaults to 100)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdOfflineSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdOfflineSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdOfflineSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdOfflineSessionsGet(realm: string, id: string, first?: number, max?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdOfflineSessionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdOfflineSessionsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/offline-sessions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdOptionalClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdOptionalClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdOptionalClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdOptionalClientScopesClientScopeIdDelete(realm: string, id: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdDelete.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/optional-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param clientScopeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdOptionalClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdOptionalClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdOptionalClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdOptionalClientScopesClientScopeIdPut(realm: string, id: string, clientScopeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdPut.');
        }

        if (clientScopeId === null || clientScopeId === undefined) {
            throw new Error('Required parameter clientScopeId was null or undefined when calling realmClientsIdOptionalClientScopesClientScopeIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/optional-client-scopes/${encodeURIComponent(String(clientScopeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get optional client scopes.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdOptionalClientScopesGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdOptionalClientScopesGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdOptionalClientScopesGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdOptionalClientScopesGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdOptionalClientScopesGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdOptionalClientScopesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/optional-client-scopes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Push the client’s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdPushRevocationPost(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<GlobalRequestResult>;
    public realmClientsIdPushRevocationPost(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GlobalRequestResult>>;
    public realmClientsIdPushRevocationPost(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GlobalRequestResult>>;
    public realmClientsIdPushRevocationPost(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdPushRevocationPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdPushRevocationPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GlobalRequestResult>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/push-revocation`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the client
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdPut(body: ClientRepresentation, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsIdPut(body: ClientRepresentation, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsIdPut(body: ClientRepresentation, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsIdPut(body: ClientRepresentation, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientsIdPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate a new registration access token for the client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdRegistrationAccessTokenPost(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ClientRepresentation>;
    public realmClientsIdRegistrationAccessTokenPost(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientRepresentation>>;
    public realmClientsIdRegistrationAccessTokenPost(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientRepresentation>>;
    public realmClientsIdRegistrationAccessTokenPost(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdRegistrationAccessTokenPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdRegistrationAccessTokenPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientRepresentation>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/registration-access-token`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a user dedicated to the service account
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdServiceAccountUserGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<UserRepresentation>;
    public realmClientsIdServiceAccountUserGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserRepresentation>>;
    public realmClientsIdServiceAccountUserGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserRepresentation>>;
    public realmClientsIdServiceAccountUserGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdServiceAccountUserGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdServiceAccountUserGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/service-account-user`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get application session count   Returns a number of user sessions associated with this client   {      \&quot;count\&quot;: number  }
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdSessionCountGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmClientsIdSessionCountGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmClientsIdSessionCountGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmClientsIdSessionCountGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdSessionCountGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdSessionCountGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/session-count`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test if registered cluster nodes are available   Tests availability by sending &#x27;ping&#x27; request to all cluster nodes.
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdTestNodesAvailableGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<GlobalRequestResult>;
    public realmClientsIdTestNodesAvailableGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GlobalRequestResult>>;
    public realmClientsIdTestNodesAvailableGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GlobalRequestResult>>;
    public realmClientsIdTestNodesAvailableGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdTestNodesAvailableGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdTestNodesAvailableGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GlobalRequestResult>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/test-nodes-available`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get user sessions for client   Returns a list of user sessions associated with this client
     * 
     * @param realm realm name (not id!)
     * @param id id of client (not client-id)
     * @param first Paging offset
     * @param max Maximum results size (defaults to 100)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsIdUserSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmClientsIdUserSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmClientsIdUserSessionsGet(realm: string, id: string, first?: number, max?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmClientsIdUserSessionsGet(realm: string, id: string, first?: number, max?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsIdUserSessionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmClientsIdUserSessionsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/clients/${encodeURIComponent(String(id))}/user-sessions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new client   Client’s client_id must be unique!
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmClientsPost(body: ClientRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmClientsPost(body: ClientRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmClientsPost(body: ClientRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmClientsPost(body: ClientRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmClientsPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmClientsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/clients`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
