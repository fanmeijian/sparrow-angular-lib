/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { GroupRepresentation } from '../model/groupRepresentation';
import { ManagementPermissionReference } from '../model/managementPermissionReference';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class GroupsService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns the groups counts.
     * 
     * @param realm realm name (not id!)
     * @param search 
     * @param top 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsCountGet(realm: string, search?: string, top?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public realmGroupsCountGet(realm: string, search?: string, top?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public realmGroupsCountGet(realm: string, search?: string, top?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public realmGroupsCountGet(realm: string, search?: string, top?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsCountGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (top !== undefined && top !== null) {
            queryParameters = queryParameters.set('top', <any>top);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: any; }>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get group hierarchy.
     * 
     * @param realm realm name (not id!)
     * @param briefRepresentation 
     * @param exact 
     * @param first 
     * @param max 
     * @param q 
     * @param search 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsGet(realm: string, briefRepresentation?: boolean, exact?: boolean, first?: number, max?: number, q?: string, search?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmGroupsGet(realm: string, briefRepresentation?: boolean, exact?: boolean, first?: number, max?: number, q?: string, search?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmGroupsGet(realm: string, briefRepresentation?: boolean, exact?: boolean, first?: number, max?: number, q?: string, search?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmGroupsGet(realm: string, briefRepresentation?: boolean, exact?: boolean, first?: number, max?: number, q?: string, search?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsGet.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (briefRepresentation !== undefined && briefRepresentation !== null) {
            queryParameters = queryParameters.set('briefRepresentation', <any>briefRepresentation);
        }
        if (exact !== undefined && exact !== null) {
            queryParameters = queryParameters.set('exact', <any>exact);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (q !== undefined && q !== null) {
            queryParameters = queryParameters.set('q', <any>q);
        }
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set or create child.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdChildrenPost(body: GroupRepresentation, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmGroupsIdChildrenPost(body: GroupRepresentation, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmGroupsIdChildrenPost(body: GroupRepresentation, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmGroupsIdChildrenPost(body: GroupRepresentation, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmGroupsIdChildrenPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdChildrenPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdChildrenPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}/children`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdDelete(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmGroupsIdDelete(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmGroupsIdDelete(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmGroupsIdDelete(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdDelete.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<GroupRepresentation>;
    public realmGroupsIdGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GroupRepresentation>>;
    public realmGroupsIdGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GroupRepresentation>>;
    public realmGroupsIdGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GroupRepresentation>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdManagementPermissionsGet(realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmGroupsIdManagementPermissionsGet(realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmGroupsIdManagementPermissionsGet(realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmGroupsIdManagementPermissionsGet(realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdManagementPermissionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdManagementPermissionsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ManagementPermissionReference>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}/management/permissions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ManagementPermissionReference>;
    public realmGroupsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ManagementPermissionReference>>;
    public realmGroupsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ManagementPermissionReference>>;
    public realmGroupsIdManagementPermissionsPut(body: ManagementPermissionReference, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmGroupsIdManagementPermissionsPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdManagementPermissionsPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdManagementPermissionsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ManagementPermissionReference>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}/management/permissions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get users   Returns a stream of users, filtered according to query parameters
     * 
     * @param realm realm name (not id!)
     * @param id 
     * @param briefRepresentation Only return basic information (only guaranteed to return id, username, created, first and last name,  email, enabled state, email verification state, federation link, and access.  Note that it means that namely user attributes, required actions, and not before are not returned.)
     * @param first Pagination offset
     * @param max Maximum results size (defaults to 100)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdMembersGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<{ [key: string]: any; }>>;
    public realmGroupsIdMembersGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<{ [key: string]: any; }>>>;
    public realmGroupsIdMembersGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<{ [key: string]: any; }>>>;
    public realmGroupsIdMembersGet(realm: string, id: string, briefRepresentation?: boolean, first?: number, max?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdMembersGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdMembersGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (briefRepresentation !== undefined && briefRepresentation !== null) {
            queryParameters = queryParameters.set('briefRepresentation', <any>briefRepresentation);
        }
        if (first !== undefined && first !== null) {
            queryParameters = queryParameters.set('first', <any>first);
        }
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<{ [key: string]: any; }>>('get',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}/members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update group, ignores subgroups.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsIdPut(body: GroupRepresentation, realm: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmGroupsIdPut(body: GroupRepresentation, realm: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmGroupsIdPut(body: GroupRepresentation, realm: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmGroupsIdPut(body: GroupRepresentation, realm: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmGroupsIdPut.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling realmGroupsIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/${encodeURIComponent(String(realm))}/groups/${encodeURIComponent(String(id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * create or add a top level realm groupSet or create child.
     * 
     * @param body 
     * @param realm realm name (not id!)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public realmGroupsPost(body: GroupRepresentation, realm: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public realmGroupsPost(body: GroupRepresentation, realm: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public realmGroupsPost(body: GroupRepresentation, realm: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public realmGroupsPost(body: GroupRepresentation, realm: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling realmGroupsPost.');
        }

        if (realm === null || realm === undefined) {
            throw new Error('Required parameter realm was null or undefined when calling realmGroupsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/${encodeURIComponent(String(realm))}/groups`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
