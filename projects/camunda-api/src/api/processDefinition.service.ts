/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.19.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ActivityStatisticsResultDto } from '../model/activityStatisticsResultDto';
import { AuthorizationExceptionDto } from '../model/authorizationExceptionDto';
import { BatchDto } from '../model/batchDto';
import { CalledProcessDefinitionDto } from '../model/calledProcessDefinitionDto';
import { CountResultDto } from '../model/countResultDto';
import { ExceptionDto } from '../model/exceptionDto';
import { FormDto } from '../model/formDto';
import { HistoryTimeToLiveDto } from '../model/historyTimeToLiveDto';
import { ProcessDefinitionDiagramDto } from '../model/processDefinitionDiagramDto';
import { ProcessDefinitionDto } from '../model/processDefinitionDto';
import { ProcessDefinitionStatisticsResultDto } from '../model/processDefinitionStatisticsResultDto';
import { ProcessDefinitionSuspensionStateDto } from '../model/processDefinitionSuspensionStateDto';
import { ProcessInstanceDto } from '../model/processInstanceDto';
import { ProcessInstanceWithVariablesDto } from '../model/processInstanceWithVariablesDto';
import { RestartProcessInstanceDto } from '../model/restartProcessInstanceDto';
import { StartProcessInstanceDto } from '../model/startProcessInstanceDto';
import { StartProcessInstanceFormDto } from '../model/startProcessInstanceFormDto';
import { VariableValueDto } from '../model/variableValueDto';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProcessDefinitionService {

    protected basePath = 'http://{host}:{port}/{contextPath}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete
     * Deletes a running process instance by id.
     * @param id The id of the process definition to be deleted.
     * @param cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param skipCustomListeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param skipIoMappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProcessDefinition.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cascade !== undefined && cascade !== null) {
            queryParameters = queryParameters.set('cascade', <any>cascade);
        }
        if (skipCustomListeners !== undefined && skipCustomListeners !== null) {
            queryParameters = queryParameters.set('skipCustomListeners', <any>skipCustomListeners);
        }
        if (skipIoMappings !== undefined && skipIoMappings !== null) {
            queryParameters = queryParameters.set('skipIoMappings', <any>skipIoMappings);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete By Key
     * Deletes process definitions by a given key which belong to no tenant id.
     * @param key The key of the process definitions to be deleted.
     * @param cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param skipCustomListeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param skipIoMappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteProcessDefinitionsByKey.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cascade !== undefined && cascade !== null) {
            queryParameters = queryParameters.set('cascade', <any>cascade);
        }
        if (skipCustomListeners !== undefined && skipCustomListeners !== null) {
            queryParameters = queryParameters.set('skipCustomListeners', <any>skipCustomListeners);
        }
        if (skipIoMappings !== undefined && skipIoMappings !== null) {
            queryParameters = queryParameters.set('skipIoMappings', <any>skipIoMappings);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete By Key
     * Deletes process definitions by a given key and which belong to a tenant id.
     * @param key The key of the process definitions to be deleted.
     * @param tenantId The id of the tenant the process definitions belong to.
     * @param cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param skipCustomListeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param skipIoMappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cascade !== undefined && cascade !== null) {
            queryParameters = queryParameters.set('cascade', <any>cascade);
        }
        if (skipCustomListeners !== undefined && skipCustomListeners !== null) {
            queryParameters = queryParameters.set('skipCustomListeners', <any>skipCustomListeners);
        }
        if (skipIoMappings !== undefined && skipIoMappings !== null) {
            queryParameters = queryParameters.set('skipIoMappings', <any>skipIoMappings);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Activity Instance Statistics
     * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @param id The id of the process definition.
     * @param failedJobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param incidentsForType If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityStatisticsResultDto>>;
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivityStatistics.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (failedJobs !== undefined && failedJobs !== null) {
            queryParameters = queryParameters.set('failedJobs', <any>failedJobs);
        }
        if (incidents !== undefined && incidents !== null) {
            queryParameters = queryParameters.set('incidents', <any>incidents);
        }
        if (incidentsForType !== undefined && incidentsForType !== null) {
            queryParameters = queryParameters.set('incidentsForType', <any>incidentsForType);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ActivityStatisticsResultDto>>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Activity Instance Statistics
     * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param failedJobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param incidentsForType If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityStatisticsResultDto>>;
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKey.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (failedJobs !== undefined && failedJobs !== null) {
            queryParameters = queryParameters.set('failedJobs', <any>failedJobs);
        }
        if (incidents !== undefined && incidents !== null) {
            queryParameters = queryParameters.set('incidents', <any>incidents);
        }
        if (incidentsForType !== undefined && incidentsForType !== null) {
            queryParameters = queryParameters.set('incidentsForType', <any>incidentsForType);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ActivityStatisticsResultDto>>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Activity Instance Statistics
     * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param failedJobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param incidentsForType If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityStatisticsResultDto>>;
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityStatisticsResultDto>>>;
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (failedJobs !== undefined && failedJobs !== null) {
            queryParameters = queryParameters.set('failedJobs', <any>failedJobs);
        }
        if (incidents !== undefined && incidents !== null) {
            queryParameters = queryParameters.set('incidents', <any>incidents);
        }
        if (incidentsForType !== undefined && incidentsForType !== null) {
            queryParameters = queryParameters.set('incidentsForType', <any>incidentsForType);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ActivityStatisticsResultDto>>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Deployed Start Form
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#embedded-task-forms).
     * @param id The id of the process definition to get the deployed start form for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeployedStartForm(id: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getDeployedStartForm(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getDeployedStartForm(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getDeployedStartForm(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDeployedStartForm.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/deployed-start-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Deployed Start Form
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#embedded-task-forms).
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeployedStartFormByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getDeployedStartFormByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getDeployedStartFormByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getDeployedStartFormByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getDeployedStartFormByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/deployed-start-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Deployed Start Form
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#embedded-task-forms).
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definitions belong to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/deployed-start-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get
     * Retrieves the latest version of the process definition for tenant according to the &#x60;ProcessDefinition&#x60; interface in the engine.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDto>;
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDto>>;
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDto>>;
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getLatestProcessDefinitionByTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getLatestProcessDefinitionByTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get
     * Retrieves a process definition according to the &#x60;ProcessDefinition&#x60; interface in the engine.
     * @param id The id of the process definition to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinition(id: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDto>;
    public getProcessDefinition(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDto>>;
    public getProcessDefinition(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDto>>;
    public getProcessDefinition(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProcessDefinition.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDto>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get XML
     * Retrieves the BPMN 2.0 XML of a process definition.
     * @param id The id of the process definition.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionBpmn20Xml(id: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDiagramDto>;
    public getProcessDefinitionBpmn20Xml(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20Xml(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20Xml(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProcessDefinitionBpmn20Xml.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDiagramDto>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/xml`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get XML
     * Retrieves latest version the BPMN 2.0 XML of a process definition.
     * @param key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionBpmn20XmlByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDiagramDto>;
    public getProcessDefinitionBpmn20XmlByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20XmlByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20XmlByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDiagramDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/xml`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get XML
     * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
     * @param key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDiagramDto>;
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDiagramDto>>;
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDiagramDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/xml`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get
     * Retrieves the latest version of the process definition which belongs to no tenant according to the &#x60;ProcessDefinition&#x60; interface in the engine.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionDto>;
    public getProcessDefinitionByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionDto>>;
    public getProcessDefinitionByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionDto>>;
    public getProcessDefinitionByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getProcessDefinitionByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProcessDefinitionDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Diagram
     * Retrieves the diagram of a process definition.  If the process definition&#x27;s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: &#x60;someProcess.bpmn&#x60; and &#x60;someProcess.png&#x60;. Supported file extentions for the image are: &#x60;svg&#x60;, &#x60;png&#x60;, &#x60;jpg&#x60;, and &#x60;gif&#x60;.
     * @param id The id of the process definition.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionDiagram(id: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getProcessDefinitionDiagram(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getProcessDefinitionDiagram(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getProcessDefinitionDiagram(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProcessDefinitionDiagram.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            '*/*',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/diagram`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Diagram
     * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition&#x27;s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: &#x60;someProcess.bpmn&#x60; and &#x60;someProcess.png&#x60;. Supported file extentions for the image are: &#x60;svg&#x60;, &#x60;png&#x60;, &#x60;jpg&#x60;, and &#x60;gif&#x60;.
     * @param key The key of the process definition.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionDiagramByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getProcessDefinitionDiagramByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getProcessDefinitionDiagramByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getProcessDefinitionDiagramByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            '*/*',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/diagram`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Diagram
     * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition&#x27;s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: &#x60;someProcess.bpmn&#x60; and &#x60;someProcess.png&#x60;. Supported file extentions for the image are: &#x60;svg&#x60;, &#x60;png&#x60;, &#x60;jpg&#x60;, and &#x60;gif&#x60;.
     * @param key The key of the process definition.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            '*/*',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/diagram`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Process Instance Statistics
     * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @param failedJobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param incidentsForType If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param rootIncidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ProcessDefinitionStatisticsResultDto>>;
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ProcessDefinitionStatisticsResultDto>>>;
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProcessDefinitionStatisticsResultDto>>>;
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (failedJobs !== undefined && failedJobs !== null) {
            queryParameters = queryParameters.set('failedJobs', <any>failedJobs);
        }
        if (incidents !== undefined && incidents !== null) {
            queryParameters = queryParameters.set('incidents', <any>incidents);
        }
        if (incidentsForType !== undefined && incidentsForType !== null) {
            queryParameters = queryParameters.set('incidentsForType', <any>incidentsForType);
        }
        if (rootIncidents !== undefined && rootIncidents !== null) {
            queryParameters = queryParameters.set('rootIncidents', <any>rootIncidents);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ProcessDefinitionStatisticsResultDto>>('get',`${this.basePath}/process-definition/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List
     * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.19/reference/rest/process-definition/get-query-count/) method.
     * @param processDefinitionId Filter by process definition id.
     * @param processDefinitionIdIn Filter by a comma-separated list of process definition ids.
     * @param name Filter by process definition name.
     * @param nameLike Filter by process definition names that the parameter is a substring of.
     * @param deploymentId Filter by the deployment the id belongs to.
     * @param deployedAfter Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param deployedAt Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param keysIn Filter by a comma-separated list of process definition keys.
     * @param keyLike Filter by process definition keys that the parameter is a substring of.
     * @param category Filter by process definition category. Exact match.
     * @param categoryLike Filter by process definition categories that the parameter is a substring of.
     * @param version Filter by process definition version.
     * @param latestVersion Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param resourceName Filter by the name of the process definition resource. Exact match.
     * @param resourceNameLike Filter by names of those process definition resources that the parameter is a substring of.
     * @param startableBy Filter by a user name who is allowed to start the process.
     * @param active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentId Filter by the incident id.
     * @param incidentType Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param tenantIdIn Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param withoutTenantId Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param includeProcessDefinitionsWithoutTenantId Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param versionTag Filter by the version tag.
     * @param versionTagLike Filter by the version tag that the parameter is a substring of.
     * @param withoutVersionTag Only include process definitions without a &#x60;versionTag&#x60;.
     * @param startableInTasklist Filter by process definitions which are startable in Tasklist..
     * @param notStartableInTasklist Filter by process definitions which are not startable in Tasklist.
     * @param startablePermissionCheck Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param sortBy Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param sortOrder Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ProcessDefinitionDto>>;
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ProcessDefinitionDto>>>;
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProcessDefinitionDto>>>;
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionIdIn !== undefined && processDefinitionIdIn !== null) {
            queryParameters = queryParameters.set('processDefinitionIdIn', <any>processDefinitionIdIn);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (nameLike !== undefined && nameLike !== null) {
            queryParameters = queryParameters.set('nameLike', <any>nameLike);
        }
        if (deploymentId !== undefined && deploymentId !== null) {
            queryParameters = queryParameters.set('deploymentId', <any>deploymentId);
        }
        if (deployedAfter !== undefined && deployedAfter !== null) {
            queryParameters = queryParameters.set('deployedAfter', <any>deployedAfter.toISOString());
        }
        if (deployedAt !== undefined && deployedAt !== null) {
            queryParameters = queryParameters.set('deployedAt', <any>deployedAt.toISOString());
        }
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }
        if (keysIn !== undefined && keysIn !== null) {
            queryParameters = queryParameters.set('keysIn', <any>keysIn);
        }
        if (keyLike !== undefined && keyLike !== null) {
            queryParameters = queryParameters.set('keyLike', <any>keyLike);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }
        if (categoryLike !== undefined && categoryLike !== null) {
            queryParameters = queryParameters.set('categoryLike', <any>categoryLike);
        }
        if (version !== undefined && version !== null) {
            queryParameters = queryParameters.set('version', <any>version);
        }
        if (latestVersion !== undefined && latestVersion !== null) {
            queryParameters = queryParameters.set('latestVersion', <any>latestVersion);
        }
        if (resourceName !== undefined && resourceName !== null) {
            queryParameters = queryParameters.set('resourceName', <any>resourceName);
        }
        if (resourceNameLike !== undefined && resourceNameLike !== null) {
            queryParameters = queryParameters.set('resourceNameLike', <any>resourceNameLike);
        }
        if (startableBy !== undefined && startableBy !== null) {
            queryParameters = queryParameters.set('startableBy', <any>startableBy);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (incidentId !== undefined && incidentId !== null) {
            queryParameters = queryParameters.set('incidentId', <any>incidentId);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (includeProcessDefinitionsWithoutTenantId !== undefined && includeProcessDefinitionsWithoutTenantId !== null) {
            queryParameters = queryParameters.set('includeProcessDefinitionsWithoutTenantId', <any>includeProcessDefinitionsWithoutTenantId);
        }
        if (versionTag !== undefined && versionTag !== null) {
            queryParameters = queryParameters.set('versionTag', <any>versionTag);
        }
        if (versionTagLike !== undefined && versionTagLike !== null) {
            queryParameters = queryParameters.set('versionTagLike', <any>versionTagLike);
        }
        if (withoutVersionTag !== undefined && withoutVersionTag !== null) {
            queryParameters = queryParameters.set('withoutVersionTag', <any>withoutVersionTag);
        }
        if (startableInTasklist !== undefined && startableInTasklist !== null) {
            queryParameters = queryParameters.set('startableInTasklist', <any>startableInTasklist);
        }
        if (notStartableInTasklist !== undefined && notStartableInTasklist !== null) {
            queryParameters = queryParameters.set('notStartableInTasklist', <any>notStartableInTasklist);
        }
        if (startablePermissionCheck !== undefined && startablePermissionCheck !== null) {
            queryParameters = queryParameters.set('startablePermissionCheck', <any>startablePermissionCheck);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ProcessDefinitionDto>>('get',`${this.basePath}/process-definition`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List Count
     * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.19/reference/rest/process-definition/get-query/) method.
     * @param processDefinitionId Filter by process definition id.
     * @param processDefinitionIdIn Filter by a comma-separated list of process definition ids.
     * @param name Filter by process definition name.
     * @param nameLike Filter by process definition names that the parameter is a substring of.
     * @param deploymentId Filter by the deployment the id belongs to.
     * @param deployedAfter Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param deployedAt Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param keysIn Filter by a comma-separated list of process definition keys.
     * @param keyLike Filter by process definition keys that the parameter is a substring of.
     * @param category Filter by process definition category. Exact match.
     * @param categoryLike Filter by process definition categories that the parameter is a substring of.
     * @param version Filter by process definition version.
     * @param latestVersion Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param resourceName Filter by the name of the process definition resource. Exact match.
     * @param resourceNameLike Filter by names of those process definition resources that the parameter is a substring of.
     * @param startableBy Filter by a user name who is allowed to start the process.
     * @param active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentId Filter by the incident id.
     * @param incidentType Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param tenantIdIn Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param withoutTenantId Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param includeProcessDefinitionsWithoutTenantId Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param versionTag Filter by the version tag.
     * @param versionTagLike Filter by the version tag that the parameter is a substring of.
     * @param withoutVersionTag Only include process definitions without a &#x60;versionTag&#x60;.
     * @param startableInTasklist Filter by process definitions which are startable in Tasklist..
     * @param notStartableInTasklist Filter by process definitions which are not startable in Tasklist.
     * @param startablePermissionCheck Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionIdIn !== undefined && processDefinitionIdIn !== null) {
            queryParameters = queryParameters.set('processDefinitionIdIn', <any>processDefinitionIdIn);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (nameLike !== undefined && nameLike !== null) {
            queryParameters = queryParameters.set('nameLike', <any>nameLike);
        }
        if (deploymentId !== undefined && deploymentId !== null) {
            queryParameters = queryParameters.set('deploymentId', <any>deploymentId);
        }
        if (deployedAfter !== undefined && deployedAfter !== null) {
            queryParameters = queryParameters.set('deployedAfter', <any>deployedAfter.toISOString());
        }
        if (deployedAt !== undefined && deployedAt !== null) {
            queryParameters = queryParameters.set('deployedAt', <any>deployedAt.toISOString());
        }
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }
        if (keysIn !== undefined && keysIn !== null) {
            queryParameters = queryParameters.set('keysIn', <any>keysIn);
        }
        if (keyLike !== undefined && keyLike !== null) {
            queryParameters = queryParameters.set('keyLike', <any>keyLike);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }
        if (categoryLike !== undefined && categoryLike !== null) {
            queryParameters = queryParameters.set('categoryLike', <any>categoryLike);
        }
        if (version !== undefined && version !== null) {
            queryParameters = queryParameters.set('version', <any>version);
        }
        if (latestVersion !== undefined && latestVersion !== null) {
            queryParameters = queryParameters.set('latestVersion', <any>latestVersion);
        }
        if (resourceName !== undefined && resourceName !== null) {
            queryParameters = queryParameters.set('resourceName', <any>resourceName);
        }
        if (resourceNameLike !== undefined && resourceNameLike !== null) {
            queryParameters = queryParameters.set('resourceNameLike', <any>resourceNameLike);
        }
        if (startableBy !== undefined && startableBy !== null) {
            queryParameters = queryParameters.set('startableBy', <any>startableBy);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (incidentId !== undefined && incidentId !== null) {
            queryParameters = queryParameters.set('incidentId', <any>incidentId);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (includeProcessDefinitionsWithoutTenantId !== undefined && includeProcessDefinitionsWithoutTenantId !== null) {
            queryParameters = queryParameters.set('includeProcessDefinitionsWithoutTenantId', <any>includeProcessDefinitionsWithoutTenantId);
        }
        if (versionTag !== undefined && versionTag !== null) {
            queryParameters = queryParameters.set('versionTag', <any>versionTag);
        }
        if (versionTagLike !== undefined && versionTagLike !== null) {
            queryParameters = queryParameters.set('versionTagLike', <any>versionTagLike);
        }
        if (withoutVersionTag !== undefined && withoutVersionTag !== null) {
            queryParameters = queryParameters.set('withoutVersionTag', <any>withoutVersionTag);
        }
        if (startableInTasklist !== undefined && startableInTasklist !== null) {
            queryParameters = queryParameters.set('startableInTasklist', <any>startableInTasklist);
        }
        if (notStartableInTasklist !== undefined && notStartableInTasklist !== null) {
            queryParameters = queryParameters.set('notStartableInTasklist', <any>notStartableInTasklist);
        }
        if (startablePermissionCheck !== undefined && startablePermissionCheck !== null) {
            queryParameters = queryParameters.set('startablePermissionCheck', <any>startablePermissionCheck);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CountResultDto>('get',`${this.basePath}/process-definition/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Rendered Start Form
     * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param id The id of the process definition to get the rendered start form for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRenderedStartForm(id: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getRenderedStartForm(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getRenderedStartForm(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getRenderedStartForm(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRenderedStartForm.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/rendered-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Rendered Start Form
     * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRenderedStartFormByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getRenderedStartFormByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getRenderedStartFormByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getRenderedStartFormByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getRenderedStartFormByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/rendered-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Rendered Start Form
     * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xhtml+xml',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/rendered-form`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Key
     * Retrieves the key of the start form for a process definition. The form key corresponds to the &#x60;FormData#formKey&#x60; property in the engine.
     * @param id The id of the process definition to get the start form key for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartForm(id: string, observe?: 'body', reportProgress?: boolean): Observable<FormDto>;
    public getStartForm(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FormDto>>;
    public getStartForm(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FormDto>>;
    public getStartForm(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStartForm.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FormDto>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/startForm`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Key
     * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the &#x60;FormData#formKey&#x60; property in the engine.
     * @param key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartFormByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<FormDto>;
    public getStartFormByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FormDto>>;
    public getStartFormByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FormDto>>;
    public getStartFormByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getStartFormByKey.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FormDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/startForm`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Key
     * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the &#x60;FormData#formKey&#x60; property in the engine.
     * @param key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'body', reportProgress?: boolean): Observable<FormDto>;
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FormDto>>;
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FormDto>>;
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getStartFormByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getStartFormByKeyAndTenantId.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FormDto>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/startForm`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Variables
     * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param id The id of the process definition to retrieve the variables for.
     * @param variableNames A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param deserializeValues Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: VariableValueDto; }>;
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStartFormVariables.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (variableNames !== undefined && variableNames !== null) {
            queryParameters = queryParameters.set('variableNames', <any>variableNames);
        }
        if (deserializeValues !== undefined && deserializeValues !== null) {
            queryParameters = queryParameters.set('deserializeValues', <any>deserializeValues);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: VariableValueDto; }>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/form-variables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Variables
     * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param variableNames A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param deserializeValues Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: VariableValueDto; }>;
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getStartFormVariablesByKey.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (variableNames !== undefined && variableNames !== null) {
            queryParameters = queryParameters.set('variableNames', <any>variableNames);
        }
        if (deserializeValues !== undefined && deserializeValues !== null) {
            queryParameters = queryParameters.set('deserializeValues', <any>deserializeValues);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: VariableValueDto; }>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/form-variables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Start Form Variables
     * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param variableNames A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param deserializeValues Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: VariableValueDto; }>;
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: VariableValueDto; }>>;
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (variableNames !== undefined && variableNames !== null) {
            queryParameters = queryParameters.set('variableNames', <any>variableNames);
        }
        if (deserializeValues !== undefined && deserializeValues !== null) {
            queryParameters = queryParameters.set('deserializeValues', <any>deserializeValues);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: VariableValueDto; }>('get',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/form-variables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Static Called Process Definitions
     * For the given process, returns a list of called process definitions corresponding to the &#x60;CalledProcessDefinition&#x60; interface in the engine. The list contains all process definitions that are referenced statically by call activities in the given process. This endpoint does not resolve process definitions that are referenced with expressions. Each called process definition contains a list of call activity ids, which specifies the call activities that are calling that process. This endpoint does not resolve references to case definitions.
     * @param id The id of the process definition.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaticCalledProcessDefinitions(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CalledProcessDefinitionDto>>;
    public getStaticCalledProcessDefinitions(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CalledProcessDefinitionDto>>>;
    public getStaticCalledProcessDefinitions(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CalledProcessDefinitionDto>>>;
    public getStaticCalledProcessDefinitions(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStaticCalledProcessDefinitions.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CalledProcessDefinitionDto>>('get',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/static-called-process-definitions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Restart Process Instance
     * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.19/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/process-instance-restart/#execution).
     * @param id The id of the process definition of the process instances to restart.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restartProcessInstance(id: string, body?: RestartProcessInstanceDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restartProcessInstance(id: string, body?: RestartProcessInstanceDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restartProcessInstance(id: string, body?: RestartProcessInstanceDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restartProcessInstance(id: string, body?: RestartProcessInstanceDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling restartProcessInstance.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/restart`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Restart Process Instance Async
     * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.19/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/process-instance-restart/#execution).
     * @param id The id of the process definition of the process instances to restart.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, observe?: 'body', reportProgress?: boolean): Observable<BatchDto>;
    public restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BatchDto>>;
    public restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BatchDto>>;
    public restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling restartProcessInstanceAsyncOperation.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<BatchDto>('post',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/restart-async`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start Instance
     * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
     * @param id The id of the process definition to be retrieved.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessInstance(id: string, body?: StartProcessInstanceDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceWithVariablesDto>;
    public startProcessInstance(id: string, body?: StartProcessInstanceDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceWithVariablesDto>>;
    public startProcessInstance(id: string, body?: StartProcessInstanceDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceWithVariablesDto>>;
    public startProcessInstance(id: string, body?: StartProcessInstanceDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling startProcessInstance.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceWithVariablesDto>('post',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/start`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start Instance
     * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceWithVariablesDto>;
    public startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceWithVariablesDto>>;
    public startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceWithVariablesDto>>;
    public startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling startProcessInstanceByKey.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceWithVariablesDto>('post',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/start`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start Instance
     * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
     * @param key The key of the process definition (the latest version thereof) to be retrieved.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceWithVariablesDto>;
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceWithVariablesDto>>;
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceWithVariablesDto>>;
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceWithVariablesDto>('post',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/start`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit Start Form
     * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param id The id of the process definition to submit the form for.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public submitForm(id: string, body?: StartProcessInstanceFormDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceDto>;
    public submitForm(id: string, body?: StartProcessInstanceFormDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceDto>>;
    public submitForm(id: string, body?: StartProcessInstanceFormDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceDto>>;
    public submitForm(id: string, body?: StartProcessInstanceFormDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling submitForm.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceDto>('post',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/submit-form`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit Start Form
     * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param key The key of the process definition to submit the form for.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public submitFormByKey(key: string, body?: StartProcessInstanceFormDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceDto>;
    public submitFormByKey(key: string, body?: StartProcessInstanceFormDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceDto>>;
    public submitFormByKey(key: string, body?: StartProcessInstanceFormDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceDto>>;
    public submitFormByKey(key: string, body?: StartProcessInstanceFormDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling submitFormByKey.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceDto>('post',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/submit-form`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit Start Form
     * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.19/user-guide/task-forms/#generated-task-forms).
     * @param key The key of the process definition to submit the form for.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceDto>;
    public submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceDto>>;
    public submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceDto>>;
    public submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling submitFormByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling submitFormByKeyAndTenantId.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProcessInstanceDto>('post',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/submit-form`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update History Time to Live
     * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.19/user-guide/process-engine/history/#history-cleanup).
     * @param id The id of the process definition to change history time to live.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionId.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/history-time-to-live`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update History Time to Live
     * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.19/user-guide/process-engine/history/#history-cleanup).
     * @param key The key of the process definition to change history time to live.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKey.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/history-time-to-live`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update History Time to Live
     * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.19/user-guide/process-engine/history/#history-cleanup).
     * @param key The key of the process definition to change history time to live.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/history-time-to-live`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend By Key
     * Activates or suspends process definitions with the given process definition key.
     * @param body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend By Id
     * Activates or suspends a given process definition by id.
     * @param id The id of the process definition to activate or suspend.
     * @param body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProcessDefinitionSuspensionStateById.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/${encodeURIComponent(String(id))}/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend by Id
     * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
     * @param key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKey.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend by Id
     * Activates or suspends a given process definition by the latest version of the process definition for tenant.
     * @param key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param tenantId The id of the tenant the process definition belongs to.
     * @param body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
        }

        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/process-definition/key/${encodeURIComponent(String(key))}/tenant-id/${encodeURIComponent(String(tenantId))}/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
