/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.19.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BatchDto } from '../model/batchDto';
import { CountResultDto } from '../model/countResultDto';
import { ExceptionDto } from '../model/exceptionDto';
import { JobDto } from '../model/jobDto';
import { JobDuedateDto } from '../model/jobDuedateDto';
import { JobQueryDto } from '../model/jobQueryDto';
import { JobRetriesDto } from '../model/jobRetriesDto';
import { JobSuspensionStateDto } from '../model/jobSuspensionStateDto';
import { PriorityDto } from '../model/priorityDto';
import { SetJobRetriesDto } from '../model/setJobRetriesDto';
import { SuspensionStateDto } from '../model/suspensionStateDto';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class JobService {

    protected basePath = 'http://{host}:{port}/{contextPath}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete Job
     * Deletes a job by id.
     * @param id The id of the job to be deleted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteJob(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteJob(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteJob(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteJob(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteJob.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/job/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Execute Job
     * Executes a job by id. **Note:** The execution of the job happens synchronously in the same thread.
     * @param id The id of the job to be executed.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeJob(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public executeJob(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public executeJob(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public executeJob(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling executeJob.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/job/${encodeURIComponent(String(id))}/execute`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job
     * Retrieves a job by id, according to the &#x60;Job&#x60; interface in the engine.
     * @param id The id of the job to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJob(id: string, observe?: 'body', reportProgress?: boolean): Observable<JobDto>;
    public getJob(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDto>>;
    public getJob(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDto>>;
    public getJob(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getJob.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<JobDto>('get',`${this.basePath}/job/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Jobs
     * Queries for jobs that fulfill given parameters. The size of the result set can be retrieved by using the [Get Job Count](https://docs.camunda.org/manual/7.19/reference/rest/job/get-query-count/) method.
     * @param jobId Filter by job id.
     * @param jobIds Filter by a comma-separated list of job ids.
     * @param jobDefinitionId Only select jobs which exist for the given job definition.
     * @param processInstanceId Only select jobs which exist for the given process instance.
     * @param processInstanceIds Only select jobs which exist for the given comma-separated list of process instance ids.
     * @param executionId Only select jobs which exist for the given execution.
     * @param processDefinitionId Filter by the id of the process definition the jobs run on.
     * @param processDefinitionKey Filter by the key of the process definition the jobs run on.
     * @param activityId Only select jobs which exist for an activity with the given id.
     * @param withRetriesLeft Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param executable Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param timers Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param messages Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param dueDates Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param createTimes Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param withException Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param exceptionMessage Only select jobs that failed due to an exception with the given message.
     * @param failedActivityId Only select jobs that failed due to an exception at an activity with the given id.
     * @param noRetriesLeft Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param active Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param priorityLowerThanOrEquals Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param priorityHigherThanOrEquals Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param tenantIdIn Only include jobs which belong to one of the passed comma-separated tenant ids.
     * @param withoutTenantId Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param includeJobsWithoutTenantId Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param sortBy Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param sortOrder Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<JobDto>>;
    public getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<JobDto>>>;
    public getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<JobDto>>>;
    public getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (jobId !== undefined && jobId !== null) {
            queryParameters = queryParameters.set('jobId', <any>jobId);
        }
        if (jobIds !== undefined && jobIds !== null) {
            queryParameters = queryParameters.set('jobIds', <any>jobIds);
        }
        if (jobDefinitionId !== undefined && jobDefinitionId !== null) {
            queryParameters = queryParameters.set('jobDefinitionId', <any>jobDefinitionId);
        }
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (processInstanceIds !== undefined && processInstanceIds !== null) {
            queryParameters = queryParameters.set('processInstanceIds', <any>processInstanceIds);
        }
        if (executionId !== undefined && executionId !== null) {
            queryParameters = queryParameters.set('executionId', <any>executionId);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (activityId !== undefined && activityId !== null) {
            queryParameters = queryParameters.set('activityId', <any>activityId);
        }
        if (withRetriesLeft !== undefined && withRetriesLeft !== null) {
            queryParameters = queryParameters.set('withRetriesLeft', <any>withRetriesLeft);
        }
        if (executable !== undefined && executable !== null) {
            queryParameters = queryParameters.set('executable', <any>executable);
        }
        if (timers !== undefined && timers !== null) {
            queryParameters = queryParameters.set('timers', <any>timers);
        }
        if (messages !== undefined && messages !== null) {
            queryParameters = queryParameters.set('messages', <any>messages);
        }
        if (dueDates !== undefined && dueDates !== null) {
            queryParameters = queryParameters.set('dueDates', <any>dueDates);
        }
        if (createTimes !== undefined && createTimes !== null) {
            queryParameters = queryParameters.set('createTimes', <any>createTimes);
        }
        if (withException !== undefined && withException !== null) {
            queryParameters = queryParameters.set('withException', <any>withException);
        }
        if (exceptionMessage !== undefined && exceptionMessage !== null) {
            queryParameters = queryParameters.set('exceptionMessage', <any>exceptionMessage);
        }
        if (failedActivityId !== undefined && failedActivityId !== null) {
            queryParameters = queryParameters.set('failedActivityId', <any>failedActivityId);
        }
        if (noRetriesLeft !== undefined && noRetriesLeft !== null) {
            queryParameters = queryParameters.set('noRetriesLeft', <any>noRetriesLeft);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (priorityLowerThanOrEquals !== undefined && priorityLowerThanOrEquals !== null) {
            queryParameters = queryParameters.set('priorityLowerThanOrEquals', <any>priorityLowerThanOrEquals);
        }
        if (priorityHigherThanOrEquals !== undefined && priorityHigherThanOrEquals !== null) {
            queryParameters = queryParameters.set('priorityHigherThanOrEquals', <any>priorityHigherThanOrEquals);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (includeJobsWithoutTenantId !== undefined && includeJobsWithoutTenantId !== null) {
            queryParameters = queryParameters.set('includeJobsWithoutTenantId', <any>includeJobsWithoutTenantId);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<JobDto>>('get',`${this.basePath}/job`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job Count
     * Queries for the number of jobs that fulfill given parameters. Takes the same parameters as the [Get Jobs](https://docs.camunda.org/manual/7.19/reference/rest/job/get-query/) method.
     * @param jobId Filter by job id.
     * @param jobIds Filter by a comma-separated list of job ids.
     * @param jobDefinitionId Only select jobs which exist for the given job definition.
     * @param processInstanceId Only select jobs which exist for the given process instance.
     * @param processInstanceIds Only select jobs which exist for the given comma-separated list of process instance ids.
     * @param executionId Only select jobs which exist for the given execution.
     * @param processDefinitionId Filter by the id of the process definition the jobs run on.
     * @param processDefinitionKey Filter by the key of the process definition the jobs run on.
     * @param activityId Only select jobs which exist for an activity with the given id.
     * @param withRetriesLeft Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param executable Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param timers Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param messages Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param dueDates Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param createTimes Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param withException Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param exceptionMessage Only select jobs that failed due to an exception with the given message.
     * @param failedActivityId Only select jobs that failed due to an exception at an activity with the given id.
     * @param noRetriesLeft Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param active Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param priorityLowerThanOrEquals Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param priorityHigherThanOrEquals Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param tenantIdIn Only include jobs which belong to one of the passed comma-separated tenant ids.
     * @param withoutTenantId Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param includeJobsWithoutTenantId Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (jobId !== undefined && jobId !== null) {
            queryParameters = queryParameters.set('jobId', <any>jobId);
        }
        if (jobIds !== undefined && jobIds !== null) {
            queryParameters = queryParameters.set('jobIds', <any>jobIds);
        }
        if (jobDefinitionId !== undefined && jobDefinitionId !== null) {
            queryParameters = queryParameters.set('jobDefinitionId', <any>jobDefinitionId);
        }
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (processInstanceIds !== undefined && processInstanceIds !== null) {
            queryParameters = queryParameters.set('processInstanceIds', <any>processInstanceIds);
        }
        if (executionId !== undefined && executionId !== null) {
            queryParameters = queryParameters.set('executionId', <any>executionId);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (activityId !== undefined && activityId !== null) {
            queryParameters = queryParameters.set('activityId', <any>activityId);
        }
        if (withRetriesLeft !== undefined && withRetriesLeft !== null) {
            queryParameters = queryParameters.set('withRetriesLeft', <any>withRetriesLeft);
        }
        if (executable !== undefined && executable !== null) {
            queryParameters = queryParameters.set('executable', <any>executable);
        }
        if (timers !== undefined && timers !== null) {
            queryParameters = queryParameters.set('timers', <any>timers);
        }
        if (messages !== undefined && messages !== null) {
            queryParameters = queryParameters.set('messages', <any>messages);
        }
        if (dueDates !== undefined && dueDates !== null) {
            queryParameters = queryParameters.set('dueDates', <any>dueDates);
        }
        if (createTimes !== undefined && createTimes !== null) {
            queryParameters = queryParameters.set('createTimes', <any>createTimes);
        }
        if (withException !== undefined && withException !== null) {
            queryParameters = queryParameters.set('withException', <any>withException);
        }
        if (exceptionMessage !== undefined && exceptionMessage !== null) {
            queryParameters = queryParameters.set('exceptionMessage', <any>exceptionMessage);
        }
        if (failedActivityId !== undefined && failedActivityId !== null) {
            queryParameters = queryParameters.set('failedActivityId', <any>failedActivityId);
        }
        if (noRetriesLeft !== undefined && noRetriesLeft !== null) {
            queryParameters = queryParameters.set('noRetriesLeft', <any>noRetriesLeft);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (priorityLowerThanOrEquals !== undefined && priorityLowerThanOrEquals !== null) {
            queryParameters = queryParameters.set('priorityLowerThanOrEquals', <any>priorityLowerThanOrEquals);
        }
        if (priorityHigherThanOrEquals !== undefined && priorityHigherThanOrEquals !== null) {
            queryParameters = queryParameters.set('priorityHigherThanOrEquals', <any>priorityHigherThanOrEquals);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (includeJobsWithoutTenantId !== undefined && includeJobsWithoutTenantId !== null) {
            queryParameters = queryParameters.set('includeJobsWithoutTenantId', <any>includeJobsWithoutTenantId);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CountResultDto>('get',`${this.basePath}/job/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Exception Stacktrace
     * Retrieves the exception stacktrace corresponding to the passed job id.
     * @param id The id of the job to get the exception stacktrace for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStacktrace(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getStacktrace(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getStacktrace(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getStacktrace(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStacktrace.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/job/${encodeURIComponent(String(id))}/stacktrace`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Jobs (POST)
     * Queries for jobs that fulfill given parameters. This method is slightly more powerful than the [Get Jobs](https://docs.camunda.org/manual/7.19/reference/rest/job/get-query/) method because it allows filtering by multiple jobs of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
     * @param body 
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<JobDto>>;
    public queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<JobDto>>>;
    public queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<JobDto>>>;
    public queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<JobDto>>('post',`${this.basePath}/job`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job Count (POST)
     * Queries for jobs that fulfill given parameters. This method takes the same message body as the [Get Jobs POST](https://docs.camunda.org/manual/7.19/reference/rest/job/post- query/) method and therefore it is slightly more powerful than the [Get Job Count](https://docs.camunda.org/manual/7.19/reference/rest/job/get-query-count/) method.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryJobsCount(body?: JobQueryDto, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public queryJobsCount(body?: JobQueryDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public queryJobsCount(body?: JobQueryDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public queryJobsCount(body?: JobQueryDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CountResultDto>('post',`${this.basePath}/job/count`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Recalculate Job Due Date
     * Recalculates the due date of a job by id.
     * @param id The id of the job to be updated.
     * @param creationDateBased Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public recalculateDuedate(id: string, creationDateBased?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public recalculateDuedate(id: string, creationDateBased?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public recalculateDuedate(id: string, creationDateBased?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public recalculateDuedate(id: string, creationDateBased?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling recalculateDuedate.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (creationDateBased !== undefined && creationDateBased !== null) {
            queryParameters = queryParameters.set('creationDateBased', <any>creationDateBased);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/job/${encodeURIComponent(String(id))}/duedate/recalculate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Due Date
     * Updates the due date of a job by id.
     * @param id The id of the job to be updated.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobDuedate(id: string, body?: JobDuedateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobDuedate(id: string, body?: JobDuedateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobDuedate(id: string, body?: JobDuedateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobDuedate(id: string, body?: JobDuedateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setJobDuedate.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/job/${encodeURIComponent(String(id))}/duedate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Priority
     * Sets the execution priority of a job by id.
     * @param id The id of the job to be updated.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobPriority(id: string, body?: PriorityDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobPriority(id: string, body?: PriorityDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobPriority(id: string, body?: PriorityDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobPriority(id: string, body?: PriorityDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setJobPriority.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/job/${encodeURIComponent(String(id))}/priority`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Retries
     * Sets the retries of the job to the given number of retries by id.
     * @param id The id of the job to be updated.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobRetries(id: string, body?: JobRetriesDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobRetries(id: string, body?: JobRetriesDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobRetries(id: string, body?: JobRetriesDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobRetries(id: string, body?: JobRetriesDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setJobRetries.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/job/${encodeURIComponent(String(id))}/retries`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Retries Async (POST)
     * Create a batch to set retries of jobs asynchronously.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobRetriesAsyncOperation(body?: SetJobRetriesDto, observe?: 'body', reportProgress?: boolean): Observable<BatchDto>;
    public setJobRetriesAsyncOperation(body?: SetJobRetriesDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BatchDto>>;
    public setJobRetriesAsyncOperation(body?: SetJobRetriesDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BatchDto>>;
    public setJobRetriesAsyncOperation(body?: SetJobRetriesDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<BatchDto>('post',`${this.basePath}/job/retries`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend Job By Id
     * Activates or suspends a given job by id.
     * @param id The id of the job to activate or suspend.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateJobSuspensionState(id: string, body?: SuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateJobSuspensionState(id: string, body?: SuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateJobSuspensionState(id: string, body?: SuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateJobSuspensionState(id: string, body?: SuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateJobSuspensionState.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/job/${encodeURIComponent(String(id))}/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activate/Suspend Jobs
     * Activates or suspends jobs matching the given criterion. This can only be on of: * &#x60;jobDefinitionId&#x60; * &#x60;processDefinitionId&#x60; * &#x60;processInstanceId&#x60; * &#x60;processDefinitionKey&#x60;
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSuspensionStateBy(body?: JobSuspensionStateDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateSuspensionStateBy(body?: JobSuspensionStateDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateSuspensionStateBy(body?: JobSuspensionStateDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateSuspensionStateBy(body?: JobSuspensionStateDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/job/suspended`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
