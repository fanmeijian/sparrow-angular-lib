/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.19.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BatchDto } from '../model/batchDto';
import { CountResultDto } from '../model/countResultDto';
import { DeleteHistoricProcessInstancesDto } from '../model/deleteHistoricProcessInstancesDto';
import { DurationReportResultDto } from '../model/durationReportResultDto';
import { ExceptionDto } from '../model/exceptionDto';
import { HistoricProcessInstanceDto } from '../model/historicProcessInstanceDto';
import { HistoricProcessInstanceQueryDto } from '../model/historicProcessInstanceQueryDto';
import { SetRemovalTimeToHistoricProcessInstancesDto } from '../model/setRemovalTimeToHistoricProcessInstancesDto';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class HistoricProcessInstanceService {

    protected basePath = 'http://{host}:{port}/{contextPath}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete
     * Deletes a process instance from the history by id.
     * @param id The id of the historic process instance to be deleted.
     * @param failIfNotExists If set to &#x60;false&#x60;, the request will still be successful if the process id is not found.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteHistoricProcessInstance(id: string, failIfNotExists?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteHistoricProcessInstance(id: string, failIfNotExists?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteHistoricProcessInstance(id: string, failIfNotExists?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteHistoricProcessInstance(id: string, failIfNotExists?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteHistoricProcessInstance.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (failIfNotExists !== undefined && failIfNotExists !== null) {
            queryParameters = queryParameters.set('failIfNotExists', <any>failIfNotExists);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/history/process-instance/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Async (POST)
     * Delete multiple historic process instances asynchronously (batch). At least &#x60;historicProcessInstanceIds&#x60; or &#x60;historicProcessInstanceQuery&#x60; has to be provided. If both are provided then all instances matching query criterion and instances from the list will be deleted.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteHistoricProcessInstancesAsync(body?: DeleteHistoricProcessInstancesDto, observe?: 'body', reportProgress?: boolean): Observable<BatchDto>;
    public deleteHistoricProcessInstancesAsync(body?: DeleteHistoricProcessInstancesDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BatchDto>>;
    public deleteHistoricProcessInstancesAsync(body?: DeleteHistoricProcessInstancesDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BatchDto>>;
    public deleteHistoricProcessInstancesAsync(body?: DeleteHistoricProcessInstancesDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<BatchDto>('post',`${this.basePath}/history/process-instance/delete`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Variable Instances
     * Deletes all variables of a process instance from the history by id.
     * @param id The id of the process instance for which all historic variables are to be deleted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteHistoricVariableInstancesOfHistoricProcessInstance(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteHistoricVariableInstancesOfHistoricProcessInstance(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteHistoricVariableInstancesOfHistoricProcessInstance(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteHistoricVariableInstancesOfHistoricProcessInstance(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteHistoricVariableInstancesOfHistoricProcessInstance.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/history/process-instance/${encodeURIComponent(String(id))}/variable-instances`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get
     * Retrieves a historic process instance by id, according to the &#x60;HistoricProcessInstance&#x60; interface in the engine.
     * @param id The id of the historic process instance to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHistoricProcessInstance(id: string, observe?: 'body', reportProgress?: boolean): Observable<HistoricProcessInstanceDto>;
    public getHistoricProcessInstance(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HistoricProcessInstanceDto>>;
    public getHistoricProcessInstance(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HistoricProcessInstanceDto>>;
    public getHistoricProcessInstance(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getHistoricProcessInstance.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<HistoricProcessInstanceDto>('get',`${this.basePath}/history/process-instance/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Duration Report
     * Retrieves a report about the duration of completed process instances, grouped by a period. These reports include the maximum, minimum and average duration of all completed process instances which were started in a given period.  **Note:** This only includes historic data.
     * @param reportType **Mandatory.** Specifies the type of the report to retrieve. To retrieve a report about the duration of process instances, the value must be set to &#x60;duration&#x60;.
     * @param periodUnit **Mandatory.** Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;.
     * @param processDefinitionIdIn Filter by process definition ids. Must be a comma-separated list of process definition ids.
     * @param processDefinitionKeyIn Filter by process definition keys. Must be a comma-separated list of process definition keys.
     * @param startedBefore Restrict to instances that were started before the given date. By [default](), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2016-01-23T14:42:45.000+0200&#x60;.
     * @param startedAfter Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2016-01-23T14:42:45.000+0200&#x60;.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHistoricProcessInstanceDurationReport(reportType: string, periodUnit: string, processDefinitionIdIn?: string, processDefinitionKeyIn?: string, startedBefore?: Date, startedAfter?: Date, observe?: 'body', reportProgress?: boolean): Observable<Array<DurationReportResultDto>>;
    public getHistoricProcessInstanceDurationReport(reportType: string, periodUnit: string, processDefinitionIdIn?: string, processDefinitionKeyIn?: string, startedBefore?: Date, startedAfter?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DurationReportResultDto>>>;
    public getHistoricProcessInstanceDurationReport(reportType: string, periodUnit: string, processDefinitionIdIn?: string, processDefinitionKeyIn?: string, startedBefore?: Date, startedAfter?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DurationReportResultDto>>>;
    public getHistoricProcessInstanceDurationReport(reportType: string, periodUnit: string, processDefinitionIdIn?: string, processDefinitionKeyIn?: string, startedBefore?: Date, startedAfter?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (reportType === null || reportType === undefined) {
            throw new Error('Required parameter reportType was null or undefined when calling getHistoricProcessInstanceDurationReport.');
        }

        if (periodUnit === null || periodUnit === undefined) {
            throw new Error('Required parameter periodUnit was null or undefined when calling getHistoricProcessInstanceDurationReport.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (reportType !== undefined && reportType !== null) {
            queryParameters = queryParameters.set('reportType', <any>reportType);
        }
        if (periodUnit !== undefined && periodUnit !== null) {
            queryParameters = queryParameters.set('periodUnit', <any>periodUnit);
        }
        if (processDefinitionIdIn !== undefined && processDefinitionIdIn !== null) {
            queryParameters = queryParameters.set('processDefinitionIdIn', <any>processDefinitionIdIn);
        }
        if (processDefinitionKeyIn !== undefined && processDefinitionKeyIn !== null) {
            queryParameters = queryParameters.set('processDefinitionKeyIn', <any>processDefinitionKeyIn);
        }
        if (startedBefore !== undefined && startedBefore !== null) {
            queryParameters = queryParameters.set('startedBefore', <any>startedBefore.toISOString());
        }
        if (startedAfter !== undefined && startedAfter !== null) {
            queryParameters = queryParameters.set('startedAfter', <any>startedAfter.toISOString());
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/csv',
            'text/csv'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DurationReportResultDto>>('get',`${this.basePath}/history/process-instance/report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List
     * Queries for historic process instances that fulfill the given parameters. The size of the result set can be retrieved by using the [Get Process Instance Count](https://docs.camunda.org/manual/7.19/reference/rest/history/process-instance/get-process-instance-query-count/) method.
     * @param sortBy Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param sortOrder Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param processInstanceId Filter by process instance id.
     * @param processInstanceIds Filter by process instance ids. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processDefinitionId Filter by the process definition the instances run on.
     * @param processDefinitionKey Filter by the key of the process definition the instances run on.
     * @param processDefinitionKeyIn Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processDefinitionName Filter by the name of the process definition the instances run on.
     * @param processDefinitionNameLike Filter by process definition names that the parameter is a substring of.
     * @param processDefinitionKeyNotIn Exclude instances that belong to a set of process definitions. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processInstanceBusinessKey Filter by process instance business key.
     * @param processInstanceBusinessKeyIn Filter by a list of business keys. A process instance must have one of the given business keys. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param processInstanceBusinessKeyLike Filter by process instance business key that the parameter is a substring of.
     * @param rootProcessInstances Restrict the query to all process instances that are top level process instances.
     * @param finished Only include finished process instances. This flag includes all process instances that are completed or terminated. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param unfinished Only include unfinished process instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param withIncidents Only include process instances which have an incident. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param withRootIncidents Only include process instances which have a root incident. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentType Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentStatus Only include process instances which have an incident in status either open or resolved. To get all process instances, use the query parameter withIncidents.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param startedBefore Restrict to instances that were started before the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param startedAfter Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param finishedBefore Restrict to instances that were finished before the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param finishedAfter Restrict to instances that were finished after the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedActivityAfter Restrict to instances that executed an activity after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedActivityBefore Restrict to instances that executed an activity before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedJobAfter Restrict to instances that executed an job after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedJobBefore Restrict to instances that executed an job before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param startedBy Only include process instances that were started by the given user.
     * @param superProcessInstanceId Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param subProcessInstanceId Restrict query to one process instance that has a sub process instance with the given id.
     * @param superCaseInstanceId Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param subCaseInstanceId Restrict query to one process instance that has a sub case instance with the given id.
     * @param caseInstanceId Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param tenantIdIn Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param withoutTenantId Only include historic process instances which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param executedActivityIdIn Restrict to instances that executed an activity with one of given ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param activeActivityIdIn Restrict to instances that have an active activity with one of given ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param active Restrict to instances that are active.
     * @param suspended Restrict to instances that are suspended.
     * @param completed Restrict to instances that are completed.
     * @param externallyTerminated Restrict to instances that are externallyTerminated.
     * @param internallyTerminated Restrict to instances that are internallyTerminated.
     * @param variables Only include process instances that have/had variables with certain values. Variable filtering expressions are comma-separated and are structured as follows: A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note:** Values are always treated as String objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;.  Key and value may not contain underscore or comma characters. 
     * @param variableNamesIgnoreCase Match all variable names provided in variables case-insensitively. If set to &#x60;true&#x60; variableName and variablename are treated as equal.
     * @param variableValuesIgnoreCase Match all variable values provided in variables case-insensitively. If set to &#x60;true&#x60; variableValue and variablevalue are treated as equal.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHistoricProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<HistoricProcessInstanceDto>>;
    public getHistoricProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<HistoricProcessInstanceDto>>>;
    public getHistoricProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<HistoricProcessInstanceDto>>>;
    public getHistoricProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



















































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (processInstanceIds !== undefined && processInstanceIds !== null) {
            queryParameters = queryParameters.set('processInstanceIds', <any>processInstanceIds);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (processDefinitionKeyIn !== undefined && processDefinitionKeyIn !== null) {
            queryParameters = queryParameters.set('processDefinitionKeyIn', <any>processDefinitionKeyIn);
        }
        if (processDefinitionName !== undefined && processDefinitionName !== null) {
            queryParameters = queryParameters.set('processDefinitionName', <any>processDefinitionName);
        }
        if (processDefinitionNameLike !== undefined && processDefinitionNameLike !== null) {
            queryParameters = queryParameters.set('processDefinitionNameLike', <any>processDefinitionNameLike);
        }
        if (processDefinitionKeyNotIn !== undefined && processDefinitionKeyNotIn !== null) {
            queryParameters = queryParameters.set('processDefinitionKeyNotIn', <any>processDefinitionKeyNotIn);
        }
        if (processInstanceBusinessKey !== undefined && processInstanceBusinessKey !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKey', <any>processInstanceBusinessKey);
        }
        if (processInstanceBusinessKeyIn !== undefined && processInstanceBusinessKeyIn !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKeyIn', <any>processInstanceBusinessKeyIn);
        }
        if (processInstanceBusinessKeyLike !== undefined && processInstanceBusinessKeyLike !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKeyLike', <any>processInstanceBusinessKeyLike);
        }
        if (rootProcessInstances !== undefined && rootProcessInstances !== null) {
            queryParameters = queryParameters.set('rootProcessInstances', <any>rootProcessInstances);
        }
        if (finished !== undefined && finished !== null) {
            queryParameters = queryParameters.set('finished', <any>finished);
        }
        if (unfinished !== undefined && unfinished !== null) {
            queryParameters = queryParameters.set('unfinished', <any>unfinished);
        }
        if (withIncidents !== undefined && withIncidents !== null) {
            queryParameters = queryParameters.set('withIncidents', <any>withIncidents);
        }
        if (withRootIncidents !== undefined && withRootIncidents !== null) {
            queryParameters = queryParameters.set('withRootIncidents', <any>withRootIncidents);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentStatus !== undefined && incidentStatus !== null) {
            queryParameters = queryParameters.set('incidentStatus', <any>incidentStatus);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (startedBefore !== undefined && startedBefore !== null) {
            queryParameters = queryParameters.set('startedBefore', <any>startedBefore.toISOString());
        }
        if (startedAfter !== undefined && startedAfter !== null) {
            queryParameters = queryParameters.set('startedAfter', <any>startedAfter.toISOString());
        }
        if (finishedBefore !== undefined && finishedBefore !== null) {
            queryParameters = queryParameters.set('finishedBefore', <any>finishedBefore.toISOString());
        }
        if (finishedAfter !== undefined && finishedAfter !== null) {
            queryParameters = queryParameters.set('finishedAfter', <any>finishedAfter.toISOString());
        }
        if (executedActivityAfter !== undefined && executedActivityAfter !== null) {
            queryParameters = queryParameters.set('executedActivityAfter', <any>executedActivityAfter.toISOString());
        }
        if (executedActivityBefore !== undefined && executedActivityBefore !== null) {
            queryParameters = queryParameters.set('executedActivityBefore', <any>executedActivityBefore.toISOString());
        }
        if (executedJobAfter !== undefined && executedJobAfter !== null) {
            queryParameters = queryParameters.set('executedJobAfter', <any>executedJobAfter.toISOString());
        }
        if (executedJobBefore !== undefined && executedJobBefore !== null) {
            queryParameters = queryParameters.set('executedJobBefore', <any>executedJobBefore.toISOString());
        }
        if (startedBy !== undefined && startedBy !== null) {
            queryParameters = queryParameters.set('startedBy', <any>startedBy);
        }
        if (superProcessInstanceId !== undefined && superProcessInstanceId !== null) {
            queryParameters = queryParameters.set('superProcessInstanceId', <any>superProcessInstanceId);
        }
        if (subProcessInstanceId !== undefined && subProcessInstanceId !== null) {
            queryParameters = queryParameters.set('subProcessInstanceId', <any>subProcessInstanceId);
        }
        if (superCaseInstanceId !== undefined && superCaseInstanceId !== null) {
            queryParameters = queryParameters.set('superCaseInstanceId', <any>superCaseInstanceId);
        }
        if (subCaseInstanceId !== undefined && subCaseInstanceId !== null) {
            queryParameters = queryParameters.set('subCaseInstanceId', <any>subCaseInstanceId);
        }
        if (caseInstanceId !== undefined && caseInstanceId !== null) {
            queryParameters = queryParameters.set('caseInstanceId', <any>caseInstanceId);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (executedActivityIdIn !== undefined && executedActivityIdIn !== null) {
            queryParameters = queryParameters.set('executedActivityIdIn', <any>executedActivityIdIn);
        }
        if (activeActivityIdIn !== undefined && activeActivityIdIn !== null) {
            queryParameters = queryParameters.set('activeActivityIdIn', <any>activeActivityIdIn);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (completed !== undefined && completed !== null) {
            queryParameters = queryParameters.set('completed', <any>completed);
        }
        if (externallyTerminated !== undefined && externallyTerminated !== null) {
            queryParameters = queryParameters.set('externallyTerminated', <any>externallyTerminated);
        }
        if (internallyTerminated !== undefined && internallyTerminated !== null) {
            queryParameters = queryParameters.set('internallyTerminated', <any>internallyTerminated);
        }
        if (variables !== undefined && variables !== null) {
            queryParameters = queryParameters.set('variables', <any>variables);
        }
        if (variableNamesIgnoreCase !== undefined && variableNamesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableNamesIgnoreCase', <any>variableNamesIgnoreCase);
        }
        if (variableValuesIgnoreCase !== undefined && variableValuesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableValuesIgnoreCase', <any>variableValuesIgnoreCase);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<HistoricProcessInstanceDto>>('get',`${this.basePath}/history/process-instance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List Count
     * Queries for the number of historic process instances that fulfill the given parameters. Takes the same parameters as the [Get Process Instances](https://docs.camunda.org/manual/7.19/reference/rest/history/process-instance/get-process-instance-query/) method.
     * @param processInstanceId Filter by process instance id.
     * @param processInstanceIds Filter by process instance ids. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processDefinitionId Filter by the process definition the instances run on.
     * @param processDefinitionKey Filter by the key of the process definition the instances run on.
     * @param processDefinitionKeyIn Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processDefinitionName Filter by the name of the process definition the instances run on.
     * @param processDefinitionNameLike Filter by process definition names that the parameter is a substring of.
     * @param processDefinitionKeyNotIn Exclude instances that belong to a set of process definitions. Filter by a comma-separated list of &#x60;Strings&#x60;.
     * @param processInstanceBusinessKey Filter by process instance business key.
     * @param processInstanceBusinessKeyIn Filter by a list of business keys. A process instance must have one of the given business keys. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param processInstanceBusinessKeyLike Filter by process instance business key that the parameter is a substring of.
     * @param rootProcessInstances Restrict the query to all process instances that are top level process instances.
     * @param finished Only include finished process instances. This flag includes all process instances that are completed or terminated. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param unfinished Only include unfinished process instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param withIncidents Only include process instances which have an incident. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param withRootIncidents Only include process instances which have a root incident. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentType Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.19/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentStatus Only include process instances which have an incident in status either open or resolved. To get all process instances, use the query parameter withIncidents.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param startedBefore Restrict to instances that were started before the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param startedAfter Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param finishedBefore Restrict to instances that were finished before the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param finishedAfter Restrict to instances that were finished after the given date. By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedActivityAfter Restrict to instances that executed an activity after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedActivityBefore Restrict to instances that executed an activity before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedJobAfter Restrict to instances that executed an job after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param executedJobBefore Restrict to instances that executed an job before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.19/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param startedBy Only include process instances that were started by the given user.
     * @param superProcessInstanceId Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param subProcessInstanceId Restrict query to one process instance that has a sub process instance with the given id.
     * @param superCaseInstanceId Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param subCaseInstanceId Restrict query to one process instance that has a sub case instance with the given id.
     * @param caseInstanceId Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param tenantIdIn Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param withoutTenantId Only include historic process instances which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param executedActivityIdIn Restrict to instances that executed an activity with one of given ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param activeActivityIdIn Restrict to instances that have an active activity with one of given ids. Filter by a comma-separated list of &#x60;Strings&#x60;
     * @param active Restrict to instances that are active.
     * @param suspended Restrict to instances that are suspended.
     * @param completed Restrict to instances that are completed.
     * @param externallyTerminated Restrict to instances that are externallyTerminated.
     * @param internallyTerminated Restrict to instances that are internallyTerminated.
     * @param variables Only include process instances that have/had variables with certain values. Variable filtering expressions are comma-separated and are structured as follows: A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note:** Values are always treated as String objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;.  Key and value may not contain underscore or comma characters. 
     * @param variableNamesIgnoreCase Match all variable names provided in variables case-insensitively. If set to &#x60;true&#x60; variableName and variablename are treated as equal.
     * @param variableValuesIgnoreCase Match all variable values provided in variables case-insensitively. If set to &#x60;true&#x60; variableValue and variablevalue are treated as equal.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHistoricProcessInstancesCount(processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public getHistoricProcessInstancesCount(processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public getHistoricProcessInstancesCount(processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public getHistoricProcessInstancesCount(processInstanceId?: string, processInstanceIds?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, processDefinitionKeyNotIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, rootProcessInstances?: boolean, finished?: boolean, unfinished?: boolean, withIncidents?: boolean, withRootIncidents?: boolean, incidentType?: string, incidentStatus?: string, incidentMessage?: string, incidentMessageLike?: string, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, executedActivityAfter?: Date, executedActivityBefore?: Date, executedJobAfter?: Date, executedJobBefore?: Date, startedBy?: string, superProcessInstanceId?: string, subProcessInstanceId?: string, superCaseInstanceId?: string, subCaseInstanceId?: string, caseInstanceId?: string, tenantIdIn?: string, withoutTenantId?: boolean, executedActivityIdIn?: string, activeActivityIdIn?: string, active?: boolean, suspended?: boolean, completed?: boolean, externallyTerminated?: boolean, internallyTerminated?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {















































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (processInstanceIds !== undefined && processInstanceIds !== null) {
            queryParameters = queryParameters.set('processInstanceIds', <any>processInstanceIds);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (processDefinitionKeyIn !== undefined && processDefinitionKeyIn !== null) {
            queryParameters = queryParameters.set('processDefinitionKeyIn', <any>processDefinitionKeyIn);
        }
        if (processDefinitionName !== undefined && processDefinitionName !== null) {
            queryParameters = queryParameters.set('processDefinitionName', <any>processDefinitionName);
        }
        if (processDefinitionNameLike !== undefined && processDefinitionNameLike !== null) {
            queryParameters = queryParameters.set('processDefinitionNameLike', <any>processDefinitionNameLike);
        }
        if (processDefinitionKeyNotIn !== undefined && processDefinitionKeyNotIn !== null) {
            queryParameters = queryParameters.set('processDefinitionKeyNotIn', <any>processDefinitionKeyNotIn);
        }
        if (processInstanceBusinessKey !== undefined && processInstanceBusinessKey !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKey', <any>processInstanceBusinessKey);
        }
        if (processInstanceBusinessKeyIn !== undefined && processInstanceBusinessKeyIn !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKeyIn', <any>processInstanceBusinessKeyIn);
        }
        if (processInstanceBusinessKeyLike !== undefined && processInstanceBusinessKeyLike !== null) {
            queryParameters = queryParameters.set('processInstanceBusinessKeyLike', <any>processInstanceBusinessKeyLike);
        }
        if (rootProcessInstances !== undefined && rootProcessInstances !== null) {
            queryParameters = queryParameters.set('rootProcessInstances', <any>rootProcessInstances);
        }
        if (finished !== undefined && finished !== null) {
            queryParameters = queryParameters.set('finished', <any>finished);
        }
        if (unfinished !== undefined && unfinished !== null) {
            queryParameters = queryParameters.set('unfinished', <any>unfinished);
        }
        if (withIncidents !== undefined && withIncidents !== null) {
            queryParameters = queryParameters.set('withIncidents', <any>withIncidents);
        }
        if (withRootIncidents !== undefined && withRootIncidents !== null) {
            queryParameters = queryParameters.set('withRootIncidents', <any>withRootIncidents);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentStatus !== undefined && incidentStatus !== null) {
            queryParameters = queryParameters.set('incidentStatus', <any>incidentStatus);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (startedBefore !== undefined && startedBefore !== null) {
            queryParameters = queryParameters.set('startedBefore', <any>startedBefore.toISOString());
        }
        if (startedAfter !== undefined && startedAfter !== null) {
            queryParameters = queryParameters.set('startedAfter', <any>startedAfter.toISOString());
        }
        if (finishedBefore !== undefined && finishedBefore !== null) {
            queryParameters = queryParameters.set('finishedBefore', <any>finishedBefore.toISOString());
        }
        if (finishedAfter !== undefined && finishedAfter !== null) {
            queryParameters = queryParameters.set('finishedAfter', <any>finishedAfter.toISOString());
        }
        if (executedActivityAfter !== undefined && executedActivityAfter !== null) {
            queryParameters = queryParameters.set('executedActivityAfter', <any>executedActivityAfter.toISOString());
        }
        if (executedActivityBefore !== undefined && executedActivityBefore !== null) {
            queryParameters = queryParameters.set('executedActivityBefore', <any>executedActivityBefore.toISOString());
        }
        if (executedJobAfter !== undefined && executedJobAfter !== null) {
            queryParameters = queryParameters.set('executedJobAfter', <any>executedJobAfter.toISOString());
        }
        if (executedJobBefore !== undefined && executedJobBefore !== null) {
            queryParameters = queryParameters.set('executedJobBefore', <any>executedJobBefore.toISOString());
        }
        if (startedBy !== undefined && startedBy !== null) {
            queryParameters = queryParameters.set('startedBy', <any>startedBy);
        }
        if (superProcessInstanceId !== undefined && superProcessInstanceId !== null) {
            queryParameters = queryParameters.set('superProcessInstanceId', <any>superProcessInstanceId);
        }
        if (subProcessInstanceId !== undefined && subProcessInstanceId !== null) {
            queryParameters = queryParameters.set('subProcessInstanceId', <any>subProcessInstanceId);
        }
        if (superCaseInstanceId !== undefined && superCaseInstanceId !== null) {
            queryParameters = queryParameters.set('superCaseInstanceId', <any>superCaseInstanceId);
        }
        if (subCaseInstanceId !== undefined && subCaseInstanceId !== null) {
            queryParameters = queryParameters.set('subCaseInstanceId', <any>subCaseInstanceId);
        }
        if (caseInstanceId !== undefined && caseInstanceId !== null) {
            queryParameters = queryParameters.set('caseInstanceId', <any>caseInstanceId);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (withoutTenantId !== undefined && withoutTenantId !== null) {
            queryParameters = queryParameters.set('withoutTenantId', <any>withoutTenantId);
        }
        if (executedActivityIdIn !== undefined && executedActivityIdIn !== null) {
            queryParameters = queryParameters.set('executedActivityIdIn', <any>executedActivityIdIn);
        }
        if (activeActivityIdIn !== undefined && activeActivityIdIn !== null) {
            queryParameters = queryParameters.set('activeActivityIdIn', <any>activeActivityIdIn);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (completed !== undefined && completed !== null) {
            queryParameters = queryParameters.set('completed', <any>completed);
        }
        if (externallyTerminated !== undefined && externallyTerminated !== null) {
            queryParameters = queryParameters.set('externallyTerminated', <any>externallyTerminated);
        }
        if (internallyTerminated !== undefined && internallyTerminated !== null) {
            queryParameters = queryParameters.set('internallyTerminated', <any>internallyTerminated);
        }
        if (variables !== undefined && variables !== null) {
            queryParameters = queryParameters.set('variables', <any>variables);
        }
        if (variableNamesIgnoreCase !== undefined && variableNamesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableNamesIgnoreCase', <any>variableNamesIgnoreCase);
        }
        if (variableValuesIgnoreCase !== undefined && variableValuesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableValuesIgnoreCase', <any>variableValuesIgnoreCase);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CountResultDto>('get',`${this.basePath}/history/process-instance/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List (POST)
     * Queries for historic process instances that fulfill the given parameters. This method is slightly more powerful than the [Get Process Instance](https://docs.camunda.org/manual/7.19/reference/rest/history/process-instance/get-process-instance-query/) because it allows filtering by multiple process variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
     * @param body 
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryHistoricProcessInstances(body?: HistoricProcessInstanceQueryDto, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<HistoricProcessInstanceDto>>;
    public queryHistoricProcessInstances(body?: HistoricProcessInstanceQueryDto, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<HistoricProcessInstanceDto>>>;
    public queryHistoricProcessInstances(body?: HistoricProcessInstanceQueryDto, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<HistoricProcessInstanceDto>>>;
    public queryHistoricProcessInstances(body?: HistoricProcessInstanceQueryDto, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<HistoricProcessInstanceDto>>('post',`${this.basePath}/history/process-instance`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get List Count (POST)
     * Queries for the number of historic process instances that fulfill the given parameters. This method takes the same message body as the [Get Process Instances (POST)](https://docs.camunda.org/manual/7.19/reference/rest/history/process-instance/get-process-instance-query/) method and therefore it is slightly more powerful than the [Get Process Instance Count](https://docs.camunda.org/manual/7.19/reference/rest/history/process-instance/post-process-instance-query-count/) method.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryHistoricProcessInstancesCount(body?: HistoricProcessInstanceQueryDto, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public queryHistoricProcessInstancesCount(body?: HistoricProcessInstanceQueryDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public queryHistoricProcessInstancesCount(body?: HistoricProcessInstanceQueryDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public queryHistoricProcessInstancesCount(body?: HistoricProcessInstanceQueryDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CountResultDto>('post',`${this.basePath}/history/process-instance/count`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Removal Time Async (POST)
     * Sets the removal time to multiple historic process instances asynchronously (batch).  At least &#x60;historicProcessInstanceIds&#x60; or &#x60;historicProcessInstanceQuery&#x60; has to be provided. If both are provided, all instances matching query criterion and instances from the list will be updated with a removal time.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setRemovalTimeAsync(body?: SetRemovalTimeToHistoricProcessInstancesDto, observe?: 'body', reportProgress?: boolean): Observable<BatchDto>;
    public setRemovalTimeAsync(body?: SetRemovalTimeToHistoricProcessInstancesDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BatchDto>>;
    public setRemovalTimeAsync(body?: SetRemovalTimeToHistoricProcessInstancesDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BatchDto>>;
    public setRemovalTimeAsync(body?: SetRemovalTimeToHistoricProcessInstancesDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<BatchDto>('post',`${this.basePath}/history/process-instance/set-removal-time`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
