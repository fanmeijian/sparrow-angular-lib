/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.19.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CountResultDto } from '../model/countResultDto';
import { CreateIncidentDto } from '../model/createIncidentDto';
import { EventSubscriptionDto } from '../model/eventSubscriptionDto';
import { ExceptionDto } from '../model/exceptionDto';
import { ExecutionDto } from '../model/executionDto';
import { ExecutionQueryDto } from '../model/executionQueryDto';
import { ExecutionTriggerDto } from '../model/executionTriggerDto';
import { IncidentDto } from '../model/incidentDto';
import { PatchVariablesDto } from '../model/patchVariablesDto';
import { VariableValueDto } from '../model/variableValueDto';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ExecutionService {

    protected basePath = 'http://{host}:{port}/{contextPath}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create Incident
     * Creates a custom incident with given properties.
     * @param id The id of the execution to create a new incident for.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createIncident(id: string, body?: CreateIncidentDto, observe?: 'body', reportProgress?: boolean): Observable<IncidentDto>;
    public createIncident(id: string, body?: CreateIncidentDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IncidentDto>>;
    public createIncident(id: string, body?: CreateIncidentDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IncidentDto>>;
    public createIncident(id: string, body?: CreateIncidentDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createIncident.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<IncidentDto>('post',`${this.basePath}/execution/${encodeURIComponent(String(id))}/create-incident`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Local Execution Variable
     * Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
     * @param id The id of the execution to delete the variable from.
     * @param varName The name of the variable to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteLocalExecutionVariable(id: string, varName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteLocalExecutionVariable(id: string, varName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteLocalExecutionVariable(id: string, varName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteLocalExecutionVariable(id: string, varName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteLocalExecutionVariable.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling deleteLocalExecutionVariable.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables/${encodeURIComponent(String(varName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Execution
     * Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
     * @param id The id of the execution to be retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecution(id: string, observe?: 'body', reportProgress?: boolean): Observable<ExecutionDto>;
    public getExecution(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionDto>>;
    public getExecution(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionDto>>;
    public getExecution(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getExecution.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ExecutionDto>('get',`${this.basePath}/execution/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Executions
     * Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/7.19/reference/rest/execution/get-query-count/) method.
     * @param businessKey Filter by the business key of the process instances the executions belong to.
     * @param processDefinitionId Filter by the process definition the executions run on.
     * @param processDefinitionKey Filter by the key of the process definition the executions run on.
     * @param processInstanceId Filter by the id of the process instance the execution belongs to.
     * @param activityId Filter by the id of the activity the execution currently executes.
     * @param signalEventSubscriptionName Select only those executions that expect a signal of the given name.
     * @param messageEventSubscriptionName Select only those executions that expect a message of the given name.
     * @param active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentId Filter by the incident id.
     * @param incidentType Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param tenantIdIn Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
     * @param variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param processVariables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param variableNamesIgnoreCase Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param variableValuesIgnoreCase Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param sortBy Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param sortOrder Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ExecutionDto>>;
    public getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ExecutionDto>>>;
    public getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExecutionDto>>>;
    public getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (businessKey !== undefined && businessKey !== null) {
            queryParameters = queryParameters.set('businessKey', <any>businessKey);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (activityId !== undefined && activityId !== null) {
            queryParameters = queryParameters.set('activityId', <any>activityId);
        }
        if (signalEventSubscriptionName !== undefined && signalEventSubscriptionName !== null) {
            queryParameters = queryParameters.set('signalEventSubscriptionName', <any>signalEventSubscriptionName);
        }
        if (messageEventSubscriptionName !== undefined && messageEventSubscriptionName !== null) {
            queryParameters = queryParameters.set('messageEventSubscriptionName', <any>messageEventSubscriptionName);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (incidentId !== undefined && incidentId !== null) {
            queryParameters = queryParameters.set('incidentId', <any>incidentId);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (variables !== undefined && variables !== null) {
            queryParameters = queryParameters.set('variables', <any>variables);
        }
        if (processVariables !== undefined && processVariables !== null) {
            queryParameters = queryParameters.set('processVariables', <any>processVariables);
        }
        if (variableNamesIgnoreCase !== undefined && variableNamesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableNamesIgnoreCase', <any>variableNamesIgnoreCase);
        }
        if (variableValuesIgnoreCase !== undefined && variableValuesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableValuesIgnoreCase', <any>variableValuesIgnoreCase);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ExecutionDto>>('get',`${this.basePath}/execution`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Execution Count
     * Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/7.19/reference/rest/execution/get-query/) method.
     * @param businessKey Filter by the business key of the process instances the executions belong to.
     * @param processDefinitionId Filter by the process definition the executions run on.
     * @param processDefinitionKey Filter by the key of the process definition the executions run on.
     * @param processInstanceId Filter by the id of the process instance the execution belongs to.
     * @param activityId Filter by the id of the activity the execution currently executes.
     * @param signalEventSubscriptionName Select only those executions that expect a signal of the given name.
     * @param messageEventSubscriptionName Select only those executions that expect a message of the given name.
     * @param active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param incidentId Filter by the incident id.
     * @param incidentType Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param incidentMessage Filter by the incident message. Exact match.
     * @param incidentMessageLike Filter by the incident message that the parameter is a substring of.
     * @param tenantIdIn Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
     * @param variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param processVariables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param variableNamesIgnoreCase Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param variableValuesIgnoreCase Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (businessKey !== undefined && businessKey !== null) {
            queryParameters = queryParameters.set('businessKey', <any>businessKey);
        }
        if (processDefinitionId !== undefined && processDefinitionId !== null) {
            queryParameters = queryParameters.set('processDefinitionId', <any>processDefinitionId);
        }
        if (processDefinitionKey !== undefined && processDefinitionKey !== null) {
            queryParameters = queryParameters.set('processDefinitionKey', <any>processDefinitionKey);
        }
        if (processInstanceId !== undefined && processInstanceId !== null) {
            queryParameters = queryParameters.set('processInstanceId', <any>processInstanceId);
        }
        if (activityId !== undefined && activityId !== null) {
            queryParameters = queryParameters.set('activityId', <any>activityId);
        }
        if (signalEventSubscriptionName !== undefined && signalEventSubscriptionName !== null) {
            queryParameters = queryParameters.set('signalEventSubscriptionName', <any>signalEventSubscriptionName);
        }
        if (messageEventSubscriptionName !== undefined && messageEventSubscriptionName !== null) {
            queryParameters = queryParameters.set('messageEventSubscriptionName', <any>messageEventSubscriptionName);
        }
        if (active !== undefined && active !== null) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters = queryParameters.set('suspended', <any>suspended);
        }
        if (incidentId !== undefined && incidentId !== null) {
            queryParameters = queryParameters.set('incidentId', <any>incidentId);
        }
        if (incidentType !== undefined && incidentType !== null) {
            queryParameters = queryParameters.set('incidentType', <any>incidentType);
        }
        if (incidentMessage !== undefined && incidentMessage !== null) {
            queryParameters = queryParameters.set('incidentMessage', <any>incidentMessage);
        }
        if (incidentMessageLike !== undefined && incidentMessageLike !== null) {
            queryParameters = queryParameters.set('incidentMessageLike', <any>incidentMessageLike);
        }
        if (tenantIdIn !== undefined && tenantIdIn !== null) {
            queryParameters = queryParameters.set('tenantIdIn', <any>tenantIdIn);
        }
        if (variables !== undefined && variables !== null) {
            queryParameters = queryParameters.set('variables', <any>variables);
        }
        if (processVariables !== undefined && processVariables !== null) {
            queryParameters = queryParameters.set('processVariables', <any>processVariables);
        }
        if (variableNamesIgnoreCase !== undefined && variableNamesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableNamesIgnoreCase', <any>variableNamesIgnoreCase);
        }
        if (variableValuesIgnoreCase !== undefined && variableValuesIgnoreCase !== null) {
            queryParameters = queryParameters.set('variableValuesIgnoreCase', <any>variableValuesIgnoreCase);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CountResultDto>('get',`${this.basePath}/execution/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Local Execution Variable
     * Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
     * @param id The id of the execution to retrieve the variable from.
     * @param varName The name of the variable to get.
     * @param deserializeValue Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, observe?: 'body', reportProgress?: boolean): Observable<VariableValueDto>;
    public getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VariableValueDto>>;
    public getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VariableValueDto>>;
    public getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLocalExecutionVariable.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getLocalExecutionVariable.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (deserializeValue !== undefined && deserializeValue !== null) {
            queryParameters = queryParameters.set('deserializeValue', <any>deserializeValue);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<VariableValueDto>('get',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables/${encodeURIComponent(String(varName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Local Execution Variable (Binary)
     * Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
     * @param id The id of the execution to retrieve the variable from.
     * @param varName The name of the variable to get.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocalExecutionVariableBinary(id: string, varName: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getLocalExecutionVariableBinary(id: string, varName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getLocalExecutionVariableBinary(id: string, varName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getLocalExecutionVariableBinary(id: string, varName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLocalExecutionVariableBinary.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getLocalExecutionVariableBinary.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            'text/plain',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request('get',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables/${encodeURIComponent(String(varName))}/data`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Local Execution Variables
     * Retrieves all variables of a given execution by id.
     * @param id The id of the execution to retrieve the variables from.
     * @param deserializeValues Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocalExecutionVariables(id: string, deserializeValues?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: VariableValueDto; }>;
    public getLocalExecutionVariables(id: string, deserializeValues?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: VariableValueDto; }>>;
    public getLocalExecutionVariables(id: string, deserializeValues?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: VariableValueDto; }>>;
    public getLocalExecutionVariables(id: string, deserializeValues?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLocalExecutionVariables.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (deserializeValues !== undefined && deserializeValues !== null) {
            queryParameters = queryParameters.set('deserializeValues', <any>deserializeValues);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: VariableValueDto; }>('get',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Message Event Subscription
     * Retrieves a message event subscription for a given execution by id and a message name.
     * @param id The id of the execution that holds the subscription.
     * @param messageName The name of the message that the subscription corresponds to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessageEventSubscription(id: string, messageName: string, observe?: 'body', reportProgress?: boolean): Observable<EventSubscriptionDto>;
    public getMessageEventSubscription(id: string, messageName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EventSubscriptionDto>>;
    public getMessageEventSubscription(id: string, messageName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EventSubscriptionDto>>;
    public getMessageEventSubscription(id: string, messageName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMessageEventSubscription.');
        }

        if (messageName === null || messageName === undefined) {
            throw new Error('Required parameter messageName was null or undefined when calling getMessageEventSubscription.');
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EventSubscriptionDto>('get',`${this.basePath}/execution/${encodeURIComponent(String(id))}/messageSubscriptions/${encodeURIComponent(String(messageName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update/Delete Local Execution Variables
     * Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param id The id of the execution to set variables for.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling modifyLocalExecutionVariables.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put Local Execution Variable
     * Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
     * @param id The id of the execution to set the variable for.
     * @param varName The name of the variable to set.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putLocalExecutionVariable.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling putLocalExecutionVariable.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables/${encodeURIComponent(String(varName))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Executions (POST)
     * Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/7.19/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
     * @param body 
     * @param firstResult Pagination of results. Specifies the index of the first result to return.
     * @param maxResults Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ExecutionDto>>;
    public queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ExecutionDto>>>;
    public queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExecutionDto>>>;
    public queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (firstResult !== undefined && firstResult !== null) {
            queryParameters = queryParameters.set('firstResult', <any>firstResult);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }

        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<ExecutionDto>>('post',`${this.basePath}/execution`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Execution Count (POST)
     * Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/7.19/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/7.19/reference/rest/execution/get-query-count/) method.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryExecutionsCount(body?: ExecutionQueryDto, observe?: 'body', reportProgress?: boolean): Observable<CountResultDto>;
    public queryExecutionsCount(body?: ExecutionQueryDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountResultDto>>;
    public queryExecutionsCount(body?: ExecutionQueryDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountResultDto>>;
    public queryExecutionsCount(body?: ExecutionQueryDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CountResultDto>('post',`${this.basePath}/execution/count`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Local Execution Variable (Binary)
     * Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
     * @param id The id of the execution to set the variable for.
     * @param varName The name of the variable to set.
     * @param data 
     * @param valueType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setLocalExecutionVariableBinary.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling setLocalExecutionVariableBinary.');
        }



        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (data !== undefined) {
            formParams = formParams.append('data', <any>data) as any || formParams;
        }
        if (valueType !== undefined) {
            formParams = formParams.append('valueType', <any>valueType) as any || formParams;
        }

        return this.httpClient.request<any>('post',`${this.basePath}/execution/${encodeURIComponent(String(id))}/localVariables/${encodeURIComponent(String(varName))}/data`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger Execution
     * Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
     * @param id The id of the execution to signal.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signalExecution(id: string, body?: ExecutionTriggerDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signalExecution(id: string, body?: ExecutionTriggerDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signalExecution(id: string, body?: ExecutionTriggerDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signalExecution(id: string, body?: ExecutionTriggerDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling signalExecution.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/execution/${encodeURIComponent(String(id))}/signal`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger Message Event Subscription
     * Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#x27;s payload.
     * @param id The id of the execution to submit the message to.
     * @param messageName The name of the message that the addressed subscription corresponds to.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling triggerEvent.');
        }

        if (messageName === null || messageName === undefined) {
            throw new Error('Required parameter messageName was null or undefined when calling triggerEvent.');
        }


        let headers = this.defaultHeaders;

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/execution/${encodeURIComponent(String(id))}/messageSubscriptions/${encodeURIComponent(String(messageName))}/trigger`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
